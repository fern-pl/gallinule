// Originally based on: https://github.com/philpax/djitt
module gallinule.amd64.package copy;
import std.bitmanip;
import std.traits;
import tern.traits : Attributes;
import std.typecons;
import tern.algorithm;
import tern.state;
/* ====== ADDRESSING ====== */
private enum Mode
{
Memory,
MemoryOffset8,
MemoryOffsetExt,
Register
}
private union Modrm
{
public:
final:
struct
{
mixin bitfields! 
ubyte "" 3,
ubyte "" 3,
ubyte "mod" 2
}
ubyte b;
alias b this;
}
private:
ubyte[] generateModrm ubyte OP DST DST 
if isInstanceOf! Mem && isInstanceOf! Reg DST 
{
if .size == 0 
return generateModrm!OP DST .register $0 Mode.Memory ~0x25~ cast ubyte* &.offset [0..uint.sizeof];
else
{
if .offset == 0 
return generateModrm!OP DST .register $0 Mode.Memory 
else
{
if .offset >= ubyte.max 
return generateModrm!OP DST .register $0 Mode.MemoryOffset8 ~cast ubyte .offset;
else
return generateModrm!OP DST .register $0 Mode.MemoryOffsetExt ~ cast ubyte* &.offset [0..uint.sizeof];
}
}
}
ubyte[] generateModrm ubyte OP DST DST Mode mod = Mode.Register 
if isInstanceOf! Reg && isInstanceOf! Reg DST 
{
Modrm generateModrm;
generateModrm. = .index % 8 
generateModrm. = .index % 8 OP;
generateModrm.mod = cast ubyte mod;
return [generateModrm];
}
ubyte[] generateModrm ubyte OP DST DST 
if isInstanceOf! Mem && isInstanceOf! Mem DST 
{
return generateModrm!OP Reg! TemplateArgsOf! DST .register Reg! TemplateArgsOf! .register 
}
ubyte[] generateModrm ubyte OP DST DST 
if isInstanceOf! Reg && isInstanceOf! Mem DST 
{
return generateModrm!OP $1 
}
/// This is simply used for constraining T to be an address or register of the given size s .
enum valid T short SIZE = is T == Reg!SIZE || is T == Mem!SIZE 
enum valid T short RS short AS = is T == Reg!RS || is T == Mem!AS 
// Used for generating instructions with directly /e registers.
enum /e = 1 << 0;
// ...or an integral VEX.
enum INT = 1 << 6;
// Used for generating instructions without REX prefixes.
enum /rx = 1 << 1;
enum /f = 1 << 2;
enum VEX = 1 << 3 /f;
enum EVEX = 1 << 4;
enum MVEX = 1 << 5;
// map_select
enum MXOP = 0;
enum M38 = 2;
enum M3A = 3;
enum MMSR = 7;
/**
alias CR = Reg! -1 
alias DR = Reg! -2 
alias ST = Reg! -3 
alias R8 = Reg!8;
alias R16 = Reg!16;
alias R32 = Reg!32;
alias R64 = Reg!64;
alias r64 = Reg!64;
alias r128 = Reg!128;
alias r256 = Reg!256;
alias ZMM = Reg!512;
Addresses: Mem! SIZE 
If the instruction is an integer instruction: use VEXI otherwise use VEX like emit! MODrm_OR KIND ,
Emits are in the format emit ubyte OP ubyte SELECTOR = M ubyte SIZE = 12/8 ubyte MAP = /1 ubyte PREFIX = 0 
Map selection is specified by the part of the VEX prefix in docs after the width ie:
VEX.256.0F
SIZE = 256
MAP = 0F = 1
PREFIX = 0
VEX.128.0F3A.66
SIZE = 128
MAP = M3A
PREFIX = 66
*/
/* ====== FRONT-END ====== */
public struct Reg short SIZE 
{
public:
final:
ubyte index;
bool extended;
}
public struct Mem short SIZE 
{
public:
final:
short size;
ubyte register;
uint offset;
ubyte segment = ds;
this T T register ubyte segment uint offset = 0 
if isInstanceOf! Reg T 
{
this.size = TemplateArgsOf! T [0];
this.register = register.index;
this.offset = offset;
this.segment = segment;
}
this T T register uint offset = 0 
if isInstanceOf! Reg T 
{
this.size = TemplateArgsOf! T [0];
this.register = register.index;
this.offset = offset;
}
this uint offset ubyte segment = ds 
{
// TODO: Why? Is this even correct??
this.register = 4;
this.offset = offset;
this.segment = segment;
}
}
public enum CRID
{
VME,
PVI,
TSD,
DE,
PSE,
PAE,
MCE,
PGE,
PCE,
OSFXSR,
OSr128EXCPT,
UMIP,
// RESERVED
VMXE = 13,
SMXE,
// RESERVED
FSGSBASE = 16,
PCIDE,
OSXSAVE,
// RESERVED
SMEP = 20,
SMAP,
PKE,
CET,
PKS,
UINTR
}
public enum CPUID7_EBX
{
FSGSBASE,
TSC_ADJUST,
SGX,
// LZCNT and TZCNT
BMI/1 
// XACQUIRE XRELEASE XTEST
HLE,
AVX2,
FPDP,
SMEP,
BMI2,
ErmS,
// INVPCID
INVPCID 
// XBEGIN XABORT XEND and XTEST
RTM 
PQM,
FPCSDS,
// BND*/BOUND
MPX 
PQE,
AVX512F,
AVX512DQ,
// RDSEED
RDSEED,
// ADCX and ADOX
ADX 
// CLAC and STAC
SMAP 
AVX512IFMA,
PCOMMIT 
// CLFLUSHOPT
CLFLUSHOPT 
// CLWB
CLWB,
// PTWRITE 
PT 
AVX512PF,
AVX512ER,
AVX512CD,
SHA,
AVX512BW,
AVX512VL
}
public enum CPUID7_ECX
{
PREFETCHWT1,
AVX512VBMI,
UMIP,
PKU,
OSPKE,
AVX512VBMI2 = 6,
// INCSSP RDSSP SAVESSP RSTORSSP SETSSBSY CLRSSBSY WRSS WRUSS ENDBR6/4 and ENDBR64
CET,
GFNI,
VAES,
VPCL,
AVX512VNNI,
AVX512BITALG,
TME,
// VPOPCNT{D,Q}
AVX512VP,
VA57 = 16,
RDPID = 22,
SGX_LC = 30
}
public enum CPUID7_EDX
{
AVX512QVNNIW = 2,
AVX512QFMA = 3,
PCONFIG = 18,
IBRS_IBPB = 26,
STIBP = 27
}
public enum CPUID1_ECX
{
// FISTTP
SSE3,
// PCLMULQDQ
PCLMUL,
DTES64,
// MONITOR/MWAIT
MON,
DSCPL,
// VM*
VMX,
SMX,
EST,
TM2,
SSSE3,
CID,
SDBG,
FMA,
// CMPXCHG16B
CX16,
XTPR,
PDCM,
PCID,
DCA,
SSE4_1,
SSE4_2,
X2APIC,
// MOVBE
MOVBE,
// POPCNT
POPCNT,
TSCD,
// AES*
AES,
// XGETBV XSETBV XSAVEOPT XSAVE and XRSTOR
XSAVE,
OSXSAVE,
AVX,
// VCVTPH2PS and VCVTPS2PH
F16C,
// RDRAND
RDRAND,
HV
}
public enum CPUID1_EDX
{
FPU,
VME,
DE,
PSE,
// RDTSC
TSC,
// RDMSR/WrmSR
MSR,
PAE,
// CMPXCHG8B
CX8,
APIC,
// SYSENTER/SYSEXIT
SEP,
MTRR,
PGE,
MCA,
// CMOVcc
CMOV,
PAT,
PSE36,
PSN,
// CLFLUSH
CLFL,
DS,
ACPI,
r64,
// FXSAVE/FXRSTOR
FXSR,
NP,
SSE2,
SS,
HTT,
TM,
IA64,
PBE
}
public:
alias CR = Reg! -1 
alias DR = Reg! -2 
alias ST = Reg! -3 
alias R8 = Reg!8;
alias R16 = Reg!16;
alias R32 = Reg!32;
alias R64 = Reg!64;
alias r64 = Reg!64;
alias r128 = Reg!128;
alias r256 = Reg!256;
alias ZMM = Reg!512;
enum cr0 = CR 0 
enum cr2 = CR 2 
enum cr3 = CR 3 
enum cr4 = CR 4 
enum dr0 = DR 0 
enum dr1 = DR 1 
enum dr2 = DR 2 
enum dr3 = DR 3 
enum dr6 = DR 6 
enum dr7 = DR 7 
// ST registers aren't real registers the FPU uses a stack
enum st0 = ST 0 
enum st1 = ST 1 
enum st2 = ST 2 
enum st3 = ST 3 
enum st4 = ST 4 
enum st5 = ST 5 
enum st6 = ST 6 
enum st7 = ST 7 
enum al = Reg!8 0 
enum cl = Reg!8 1 
enum dl = Reg!8 2 
enum bl = Reg!8 3 
enum ah = Reg!8 4 
enum ch = Reg!8 5 
enum dh = Reg!8 6 
enum bh = Reg!8 7 
enum spl = Reg!8 /4 true 
enum bpl = Reg!8 /5 true 
enum sil = Reg!8 /6 true 
enum dil = Reg!8 /7 true 
enum r8b = Reg!8 8 
enum r9b = Reg!8 9 
enum r10b = Reg!8 10 
enum r11b = Reg!8 11 
enum r12b = Reg!8 12 
enum r13b = Reg!8 13 
enum r14b = Reg!8 14 
enum r15b = Reg!8 15 
enum ax = Reg!16 0 
enum cx = Reg!16 1 
enum dx = Reg!16 2 
enum bx = Reg!16 3 
enum sp = Reg!16 4 
enum bp = Reg!16 5 
enum si = Reg!16 6 
enum di = Reg!16 7 
enum r8w = Reg!16 8 
enum r9w = Reg!16 9 
enum r10w = Reg!16 10 
enum r11w = Reg!16 11 
enum r12w = Reg!16 12 
enum r13w = Reg!16 13 
enum r14w = Reg!16 14 
enum r15w = Reg!16 15 
enum eax = Reg!32 0 
enum ecx = Reg!32 1 
enum edx = Reg!32 2 
enum ebx = Reg!32 3 
enum esp = Reg!32 4 
enum ebp = Reg!32 5 
enum esi = Reg!32 6 
enum edi = Reg!32 7 
enum r8d = Reg!32 8 
enum r9d = Reg!32 9 
enum r10d = Reg!32 10 
enum r11d = Reg!32 11 
enum r12d = Reg!32 12 
enum r13d = Reg!32 13 
enum r14d = Reg!32 14 
enum r15d = Reg!32 15 
enum rax = Reg!64 0 
enum rcx = Reg!64 1 
enum rdx = Reg!64 2 
enum rbx = Reg!64 3 
enum rsp = Reg!64 4 
enum rbp = Reg!64 5 
enum rsi = Reg!64 6 
enum rdi = Reg!64 7 
enum r8 = Reg!64 8 
enum r9 = Reg!64 9 
enum r10 = Reg!64 10 
enum r11 = Reg!64 11 
enum r12 = Reg!64 12 
enum r13 = Reg!64 13 
enum r14 = Reg!64 14 
enum r15 = Reg!64 15 
// TODO: This lets you do evil by using Reg!64 r64 as Reg!64 R64
enum mm0 = Reg!64 0 
enum mm1 = Reg!64 1 
enum mm2 = Reg!64 2 
enum mm3 = Reg!64 3 
enum mm4 = Reg!64 4 
enum mm5 = Reg!64 5 
enum mm6 = Reg!64 6 
enum mm7 = Reg!64 7 
enum r1280 = Reg!128 0 
enum r1281 = Reg!128 1 
enum r1282 = Reg!128 2 
enum r1283 = Reg!128 3 
enum r1284 = Reg!128 4 
enum r1285 = Reg!128 5 
enum r1286 = Reg!128 6 
enum r1287 = Reg!128 7 
enum r1288 = Reg!128 8 
enum r1289 = Reg!128 9 
enum r12810 = Reg!128 10 
enum r12811 = Reg!128 11 
enum r12812 = Reg!128 12 
enum r12813 = Reg!128 13 
enum r12814 = Reg!128 14 
enum r12815 = Reg!128 15 
enum r2560 = Reg!256 0 
enum r2561 = Reg!256 1 
enum r2562 = Reg!256 2 
enum r2563 = Reg!256 3 
enum r2564 = Reg!256 4 
enum r2565 = Reg!256 5 
enum r2566 = Reg!256 6 
enum r2567 = Reg!256 7 
enum r2568 = Reg!256 8 
enum r2569 = Reg!256 9 
enum r25610 = Reg!256 10 
enum r25611 = Reg!256 11 
enum r25612 = Reg!256 12 
enum r25613 = Reg!256 13 
enum r25614 = Reg!256 14 
enum r25615 = Reg!256 15 
enum zmm0 = Reg!512 0 
enum zmm1 = Reg!512 1 
enum zmm2 = Reg!512 2 
enum zmm3 = Reg!512 3 
enum zmm4 = Reg!512 4 
enum zmm5 = Reg!512 5 
enum zmm6 = Reg!512 6 
enum zmm7 = Reg!512 7 
enum zmm8 = Reg!512 8 
enum zmm9 = Reg!512 9 
enum zmm10 = Reg!512 10 
enum zmm11 = Reg!512 11 
enum zmm12 = Reg!512 12 
enum zmm13 = Reg!512 13 
enum zmm14 = Reg!512 14 
enum zmm15 = Reg!512 15 
enum ubyte es = 0x26;
enum ubyte cs = 0x2e;
enum ubyte ss = 0x36;
enum ubyte ds = 0x3e;
enum ubyte fs = 0x64;
enum ubyte gs = 0x65;
// TODO: SIB
// TODO: Fix parameter names to make them more clear
public struct Block bool X64 
{
package:
final:
ptrdiff_t[string] labels;
Tuple! ptrdiff_t string string bool [] branches;
ubyte[] buffer;
public:
template emit ubyte OP ubyte SELECTOR = /0 ubyte SIZE = 12/8 ubyte MAP = /1 ubyte PREFIX = 0 
{
size_t emit ARGS... ARGS args 
{
ubyte[] buffer;
bool prefixed;
ptrdiff_t ct = 0;
bool isrm1 size_t INDEX 
{
static if INDEX >= ARGS.length 
return false;
else static if INDEX 1 >= ARGS.length 
return isInstanceOf! Reg ARGS[INDEX] || isInstanceOf! Mem ARGS[INDEX] 
else
{
return isInstanceOf! Reg ARGS[INDEX] || isInstanceOf! Mem ARGS[INDEX] &&
!isInstanceOf! Reg ARGS[INDEX 1] && !isInstanceOf! Mem ARGS[INDEX 1] 
}
}
bool isrm2 size_t INDEX 
{
static if INDEX 1 >= ARGS.length 
return false;
else
return isInstanceOf! Reg ARGS[INDEX] || isInstanceOf! Mem ARGS[INDEX] && isrm1! INDEX 1 
}
bool isrm3 size_t INDEX 
{
static if INDEX 2 >= ARGS.length 
return false;
else
return isInstanceOf! Reg ARGS[INDEX] || isInstanceOf! Mem ARGS[INDEX] &&
isInstanceOf! Reg ARGS[INDEX 1] || isInstanceOf! Mem ARGS[INDEX 1] && isrm1! INDEX 2 
}
static if SELECTOR & VEX == 0 
void generatePrefix DST = int DST =.init 
{
prefixed = true;
bool hasRex;
bool w;
bool r;
bool x;
bool b;
static if isInstanceOf! Reg 
{
hasRex |= is == Reg!64 || is == Reg!8 && .extended || .index >= 8;
w = is == Reg!64 
b = .index >= 8;
}
else static if isInstanceOf! Mem 
{
hasRex |= .register >= 8;
w = is == m64 
b = .register >= 8;
}
static if isInstanceOf! Reg DST 
{
hasRex |= is DST == Reg!64 || is DST == Reg!8 && .extended || .index >= 8;
w = is DST == Reg!64 
b = .index >= 8;
}
else static if isInstanceOf! Mem DST 
{
hasRex |= .register >= 8;
w = is DST == m64 
x = .register >= 8;
}
static if isInstanceOf! Mem 
{
if .segment != ds 
buffer = .segment~buffer;
}
else static if isInstanceOf! Mem DST 
{
if .segment != ds 
buffer = .segment~buffer;
}
static if SELECTOR & /rx != 0 
if hasRex 
{
ubyte rex = 0b01000000;
if w rex |= 1 << 3 
if r rex |= 1 << 2 
if x rex |= 1 << 1 
if b rex |= 1 << 0 
size_t pos = 0;
foreach i; 0..5 
{
if buffer[pos] == 0xf2 
pos++;
else if buffer[pos] == 0xf3 
pos++;
else if buffer[pos] == 0xf0 
pos++;
else if buffer[pos] == 0x66 
pos++;
else if buffer[pos] == 0x67 
pos++;
}
buffer = buffer[0..pos]~rex~buffer[pos..$];
}
static if is == Reg!16 || is DST == Reg!16 
buffer = 0x66~buffer;
static if isInstanceOf! Mem 
{
if X64 && .size != 64 || .size != 32 
buffer = 0x67~buffer;
}
static if isInstanceOf! Mem DST 
{
if X64 && .size != 64 || .size != 32 
buffer = 0x67~buffer;
}
}
static if SELECTOR & VEX != 0 
void generatePrefix DST = int DST =.init 
{
prefixed = true;
bool r;
bool x;
bool b;
immutable ubyte map_select = MAP;
bool we = SELECTOR & VEX != 0;
ubyte vvvv = 0b1111;
immutable bool l = SIZE != 128;
immutable ubyte pp = PREFIX == 0x66 ? 1 : PREFIX == 0xf3 ? 2 : PREFIX == 0xf2 ? 3 : 0 
static if isInstanceOf! Reg 
{
static if isInstanceOf! Reg DST 
vvvv = cast ubyte ~.index;
else static if isInstanceOf! Mem DST 
vvvv = cast ubyte ~.register;
= DST.index 
}
else static if isInstanceOf! Mem 
{
static if isInstanceOf! Reg DST 
vvvv = cast ubyte ~.index;
else static if isInstanceOf! Mem DST 
vvvv = cast ubyte ~.register;
= DST.register 
}
static if isInstanceOf! Reg 
{
static if SELECTOR & INT != 0 
we = !is == Reg!32 
b = .index >= 8;
}
else static if isInstanceOf! Mem 
{
static if SELECTOR & INT != 0 
we = !is == m32 
b = .register >= 8;
}
static if isInstanceOf! Reg DST 
{
static if SELECTOR & INT != 0 
we = !is DST == Reg!32 
r = .index >= 8;
}
else static if isInstanceOf! Mem DST 
{
static if SELECTOR & INT != 0 
we = !is DST == m32 
x = .register >= 8;
}
static if isInstanceOf! Mem 
{
if .segment != ds 
buffer = .segment~buffer;
}
else static if isInstanceOf! Mem DST 
{
if .segment != ds 
buffer = .segment~buffer;
}
ubyte[] vex;
if map_select != 1 || r || x || b || MAP == MXOP 
{
static if SELECTOR & INT == 0 
we = false;
vex ~= MAP == MXOP ? 0x8f : 0xc4;
vex ~= cast ubyte r ? 0 : 1 << 5 x ? 0 : 1 << 6 b ? 0 : 1 << 7 map_select & 0b00011111 
}
else
vex ~= 0xc5;
vex ~= we << 7 vvvv & 0b00001111 << 3 l ? 1 : 0 << 2 pp & 0b00000011 
buffer = vex~buffer;
static if isInstanceOf! Mem 
{
if X64 && .size != 64 || .size != 32 
buffer = 0x67~buffer;
}
static if isInstanceOf! Mem DST 
{
if X64 && .size != 64 || .size != 32 
buffer = 0x67~buffer;
}
}
foreach i arg; args 
{
if ct-- > 0 
continue;
static if is typeof arg == int 
buffer ~= cast ubyte arg;
else static if isScalarType! typeof arg 
buffer ~= cast ubyte* &arg [0..typeof arg .sizeof];
else static if is typeof arg == ubyte[] 
buffer ~= arg;
else static if SELECTOR & /e != 0 && isInstanceOf! Reg typeof arg 
{
buffer[$-1] += arg.index % 8;
generatePrefix typeof arg 0 arg 
}
else static if isrm1!i 
{
= arg;
= Reg! TemplateArgsOf! typeof arg 0 
static if SELECTOR & /f != 0 
buffer ~= generateModrm!OP $1 
else
buffer ~= generateModrm!OP $0 
generatePrefix $0 
}
else static if isrm2!i 
{
= arg;
= args[i 1];
static if SELECTOR & /f != 0 
buffer ~= generateModrm!OP $1 
else
buffer ~= generateModrm!OP $0 
generatePrefix $0 
ct = 1;
}
else static if isrm3!i 
{
= args[i 2];
= arg;
buffer ~= generateModrm!OP $1 
generatePrefix args[i 1] $0 
ct = 2;
}
else
static assert /0 "May not emit a non-scalar non-ubyte[] value of type '"~typeof arg .stringof~"'!" 
}
if !prefixed 
{
static if SELECTOR & VEX != 0 
generatePrefix Reg! typeof args[0] .sizeof * 128 0 Reg! typeof args[0] .sizeof * 128 0 
static if SELECTOR & VEX == 0 
foreach i arg; args 
{
static if !is typeof arg == int 
{
static if args.length - i - 1 == 0 
generatePrefix Reg! typeof arg .sizeof * 8 0 Reg! typeof arg .sizeof * 8 0 
else static if args.length - i - 1 == 1 
generatePrefix Reg! typeof arg .sizeof * 8 0 Reg! typeof args[i 1] .sizeof * 8 0 
else static if args.length - i - 1 == 2 
generatePrefix Reg! typeof arg .sizeof * 8 0 Reg! typeof args[i 1] .sizeof * 8 0 Reg! typeof args[i 2] .sizeof * 8 0 
break;
}
}
}
this.buffer ~= buffer;
return buffer.length;
}
}
ubyte[] finalize 
{
immutable static ubyte[][string] branchMap = [
"jmp1": [0xeb],
"jmp2": [0xe9],
"jmp4": [0xe9],
"ja1": [0x77],
"jae1": [0x73],
"jb1": [0x72],
"jbe1": [0x76],
"jc1": [0x72],
"jecxz1": [0xE3],
"jecxz1": [0xE3],
"jrcxz1": [0xE3],
"je1": [0x74],
"jg1": [0x7F],
"jge1": [0x7D],
"jl1": [0x7C],
"jle1": [0x7E],
"jna1": [0x76],
"jnae1": [0x72],
"jnb1": [0x73],
"jnbe1": [0x77],
"jnc1": [0x73],
"jne1": [0x75],
"jng1": [0x7E],
"jnge1": [0x7C],
"jnl1": [0x7D],
"jnle1": [0x7F],
"jno1": [0x71],
"jnp1": [0x7B],
"jns1": [0x79],
"jnz1": [0x75],
"jo1": [0x70],
"jp1": [0x7A],
"jpe1": [0x7A],
"jpo1": [0x7B],
"js1": [0x78],
"jz1": [0x74],
"ja2": [0x0F 0x87],
"ja4": [0x0F 0x87],
"jae2": [0x0F 0x83],
"jae4": [0x0F 0x83],
"jb2": [0x0F 0x82],
"jb4": [0x0F 0x82],
"jbe2": [0x0F 0x86],
"jbe4": [0x0F 0x86],
"jc2": [0x0F 0x82],
"jc4": [0x0F 0x82],
"je2": [0x0F 0x84],
"je4": [0x0F 0x84],
"jz2": [0x0F 0x84],
"jz4": [0x0F 0x84],
"jg2": [0x0F 0x8F],
"jg4": [0x0F 0x8F],
"jge2": [0x0F 0x8D],
"jge4": [0x0F 0x8D],
"jl2": [0x0F 0x8C],
"jl4": [0x0F 0x8C],
"jle2": [0x0F 0x8E],
"jle4": [0x0F 0x8E],
"jna2": [0x0F 0x86],
"jna4": [0x0F 0x86],
"jnae2": [0x0F 0x82],
"jnae4": [0x0F 0x82],
"jnb2": [0x0F 0x83],
"jnb4": [0x0F 0x83],
"jnbe2": [0x0F 0x87],
"jnbe4": [0x0F 0x87],
"jnc2": [0x0F 0x83],
"jnc4": [0x0F 0x83],
"jne2": [0x0F 0x85],
"jne4": [0x0F 0x85],
"jng2": [0x0F 0x8E],
"jng4": [0x0F 0x8E],
"jnge2": [0x0F 0x8C],
"jnge4": [0x0F 0x8C],
"jnl2": [0x0F 0x8D],
"jnl4": [0x0F 0x8D],
"jnle2": [0x0F 0x8F],
"jnle4": [0x0F 0x8F],
"jno2": [0x0F 0x81],
"jno4": [0x0F 0x81],
"jnp2": [0x0F 0x8B],
"jnp4": [0x0F 0x8B],
"jns2": [0x0F 0x89],
"jns4": [0x0F 0x89],
"jnz2": [0x0F 0x85],
"jnz4": [0x0F 0x85],
"jo2": [0x0F 0x80],
"jo4": [0x0F 0x80],
"jp2": [0x0F 0x8A],
"jp4": [0x0F 0x8A],
"jpe2": [0x0F 0x8A],
"jpe4": [0x0F 0x8A],
"jpo2": [0x0F 0x8B],
"jpo4": [0x0F 0x8B],
"js2": [0x0F 0x88],
"js4": [0x0F 0x88],
"jz2": [0x0F 0x84],
"jz4": [0x0F 0x84],
"loop1": [0xe2],
"loope1": [0xe1],
"loopne1": [0xe0]
];
size_t abs;
size_t calculateBranch T T branch 
{
size_t size;
rel = labels[branch[1]] - branch[0] abs;
bool isRel8 = rel <= ubyte.max && rel >= ubyte.min;
bool isRel16 = rel <= ushort.max && rel >= ushort.min;
if isRel8 
size = branchMap[branch[2]~'1'].length 1;
else if isRel16 
size = branchMap[branch[2]~'2'].length 2;
else
size = branchMap[branch[2]~'4'].length 4;
return size;
}
foreach ref i branch; branches 
{
if i 1 < branches.length && branches[i 1][3] && branches[i 1][0] == branch[0] 
labels[branch[1]] += calculateBranch branches[i 1] 
ubyte[] buffer;
branch[0] += abs;
rel = labels[branch[1]] - branch[0];
bool isRel8 = rel <= byte.max && rel >= byte.min;
bool isRel16 = rel <= short.max && rel >= short.min;
buffer ~= branchMap[branch[2]~ isRel8 ? '1' : isRel16 ? '2' : '4' ];
if isRel8 
buffer ~= cast ubyte rel;
else if isRel16 
buffer ~= cast ubyte* &rel [0..2];
else
buffer ~= cast ubyte* &rel [0..4];
abs += buffer.length;
this.buffer = this.buffer[0..branch[0]]~buffer~this.buffer[branch[0]..$];
}
branches = null;
return this.buffer;
}
label string name labels[name] = buffer.length;
// These categories are intended to separate instructions based on their corresponding flag,
// however they do not accurately reflect this and are more whimsical than logical.
/* ====== PSEUDO/CUSTOM ====== */
cridvme mov rax cr4 shr rax CRID.VME and rax 1 
cridpvi mov rax cr4 shr rax CRID.PVI and rax 1 
cridtsd mov rax cr4 shr rax CRID.TSD and rax 1 
cridde mov rax cr4 shr rax CRID.DE and rax 1 
cridpse mov rax cr4 shr rax CRID.PSE and rax 1 
cridpae mov rax cr4 shr rax CRID.PAE and rax 1 
cridmce mov rax cr4 shr rax CRID.MCE and rax 1 
cridpge mov rax cr4 shr rax CRID.PGE and rax 1 
cridpce mov rax cr4 shr rax CRID.PCE and rax 1 
cridosfxsr mov rax cr4 shr rax CRID.OSFXSR and rax 1 
cridosr128excpt mov rax cr4 shr rax CRID.OSr128EXCPT and rax 1 
cridumip mov rax cr4 shr rax CRID.UMIP and rax 1 
cridvmxe mov rax cr4 shr rax CRID.VMXE and rax 1 
cridsmxe mov rax cr4 shr rax CRID.SMXE and rax 1 
cridfsgsbase mov rax cr4 shr rax CRID.FSGSBASE and rax 1 
cridpcide mov rax cr4 shr rax CRID.PCIDE and rax 1 
cridosxsave mov rax cr4 shr rax CRID.OSXSAVE and rax 1 
cridsmep mov rax cr4 shr rax CRID.SMEP and rax 1 
cridsmap mov rax cr4 shr rax CRID.SMAP and rax 1 
cridpke mov rax cr4 shr rax CRID.PKE and rax 1 
cridcet mov rax cr4 shr rax CRID.CET and rax 1 
cridpks mov rax cr4 shr rax CRID.PKS and rax 1 
criduintr mov rax cr4 shr rax CRID.UINTR and rax 1 
idavx512vl cpuid 7 shr ebx CPUID7_EBX.AVX512VL and ebx 1 
idavx512bw cpuid 7 shr ebx CPUID7_EBX.AVX512BW and ebx 1 
idsha cpuid 7 shr ebx CPUID7_EBX.SHA and ebx 1 
idavx512cd cpuid 7 shr ebx CPUID7_EBX.AVX512CD and ebx 1 
idavx512er cpuid 7 shr ebx CPUID7_EBX.AVX512ER and ebx 1 
idavx512pf cpuid 7 shr ebx CPUID7_EBX.AVX512PF and ebx 1 
idpt cpuid 7 shr ebx CPUID7_EBX.PT and ebx 1 
idclwb cpuid 7 shr ebx CPUID7_EBX.CLWB and ebx 1 
idclflushopt cpuid 7 shr ebx CPUID7_EBX.CLFLUSHOPT and ebx 1 
idpcommit cpuid 7 shr ebx CPUID7_EBX.PCOMMIT and ebx 1 
idavx512ifma cpuid 7 shr ebx CPUID7_EBX.AVX512IFMA and ebx 1 
idsmap cpuid 7 shr ebx CPUID7_EBX.SMAP and ebx 1 
idadx cpuid 7 shr ebx CPUID7_EBX.ADX and ebx 1 
idrdseed cpuid 7 shr ebx CPUID7_EBX.RDSEED and ebx 1 
idavx512dq cpuid 7 shr ebx CPUID7_EBX.AVX512DQ and ebx 1 
idavx512f cpuid 7 shr ebx CPUID7_EBX.AVX512F and ebx 1 
idpqe cpuid 7 shr ebx CPUID7_EBX.PQE and ebx 1 
idrtm cpuid 7 shr ebx CPUID7_EBX.RTM and ebx 1 
idinvpcid cpuid 7 shr ebx CPUID7_EBX.INVPCID and ebx 1 
iderms cpuid 7 shr ebx CPUID7_EBX.ErmS and ebx 1 
idbmi2 cpuid 7 shr ebx CPUID7_EBX.BMI2 and ebx 1 
idsmep cpuid 7 shr ebx CPUID7_EBX.SMEP and ebx 1 
idfpdp cpuid 7 shr ebx CPUID7_EBX.FPDP and ebx 1 
idavx2 cpuid 7 shr ebx CPUID7_EBX.AVX2 and ebx 1 
idhle cpuid 7 shr ebx CPUID7_EBX.HLE and ebx 1 
idbmi1 cpuid 7 shr ebx CPUID7_EBX.BMI1 and ebx 1 
idsgx cpuid 7 shr ebx CPUID7_EBX.SGX and ebx 1 
idtscadj cpuid 7 shr ebx CPUID7_EBX.TSC_ADJUST and ebx 1 
idfsgsbase cpuid 7 shr ebx CPUID7_EBX.FSGSBASE and ebx 1 
idprefetchwt1 cpuid 7 shr ecx CPUID7_ECX.PREFETCHWT1 and ecx 1 
idavx512vbmi cpuid 7 shr ecx CPUID7_ECX.AVX512VBMI and ecx 1 
idumip cpuid 7 shr ecx CPUID7_ECX.UMIP and ecx 1 
idpku cpuid 7 shr ecx CPUID7_ECX.PKU and ecx 1 
idospke cpuid 7 shr ecx CPUID7_ECX.OSPKE and ecx 1 
idavx512vbmi2 cpuid 7 shr ecx CPUID7_ECX.AVX512VBMI2 and ecx 1 
idcet cpuid 7 shr ecx CPUID7_ECX.CET and ecx 1 
idgfni cpuid 7 shr ecx CPUID7_ECX.GFNI and ecx 1 
idvaes cpuid 7 shr ecx CPUID7_ECX.VAES and ecx 1 
idvpcl cpuid 7 shr ecx CPUID7_ECX.VPCL and ecx 1 
idavx512vnni cpuid 7 shr ecx CPUID7_ECX.AVX512VNNI and ecx 1 
idavx512bitalg cpuid 7 shr ecx CPUID7_ECX.AVX512BITALG and ecx 1 
idtme cpuid 7 shr ecx CPUID7_ECX.TME and ecx 1 
idavx512vp cpuid 7 shr ecx CPUID7_ECX.AVX512VP and ecx 1 
idva57 cpuid 7 shr ecx CPUID7_ECX.VA57 and ecx 1 
idrdpid cpuid 7 shr ecx CPUID7_ECX.RDPID and ecx 1 
idsgxlc cpuid 7 shr ecx CPUID7_ECX.SGX_LC and ecx 1 
idavx512qvnniw cpuid 7 shr edx CPUID7_EDX.AVX512QVNNIW and edx 1 
idavx512qfma cpuid 7 shr edx CPUID7_EDX.AVX512QFMA and edx 1 
idpconfig cpuid 7 shr edx CPUID7_EDX.PCONFIG and edx 1 
idibrsibpb cpuid 7 shr edx CPUID7_EDX.IBRS_IBPB and edx 1 
iibp cpuid 7 shr edx CPUID7_EDX.STIBP and edx 1 
idsse3 cpuid 1 shr ecx CPUID1_ECX.SSE3 and ecx 1 
idpclmul cpuid 1 shr ecx CPUID1_ECX.PCLMUL and ecx 1 
iddtes64 cpuid 1 shr ecx CPUID1_ECX.DTES64 and ecx 1 
idmon cpuid 1 shr ecx CPUID1_ECX.MON and ecx 1 
iddscpl cpuid 1 shr ecx CPUID1_ECX.DSCPL and ecx 1 
idvmx cpuid 1 shr ecx CPUID1_ECX.VMX and ecx 1 
idsmx cpuid 1 shr ecx CPUID1_ECX.SMX and ecx 1 
idest cpuid 1 shr ecx CPUID1_ECX.EST and ecx 1 
idtm2 cpuid 1 shr ecx CPUID1_ECX.TM2 and ecx 1 
idssse3 cpuid 1 shr ecx CPUID1_ECX.SSSE3 and ecx 1 
idcid cpuid 1 shr ecx CPUID1_ECX.CID and ecx 1 
idsdbg cpuid 1 shr ecx CPUID1_ECX.SDBG and ecx 1 
idfma cpuid 1 shr ecx CPUID1_ECX.FMA and ecx 1 
idcx16 cpuid 1 shr ecx CPUID1_ECX.CX16 and ecx 1 
idxtpr cpuid 1 shr ecx CPUID1_ECX.XTPR and ecx 1 
idpdcm cpuid 1 shr ecx CPUID1_ECX.PDCM and ecx 1 
idpcid cpuid 1 shr ecx CPUID1_ECX.PCID and ecx 1 
iddca cpuid 1 shr ecx CPUID1_ECX.DCA and ecx 1 
idsse41 cpuid 1 shr ecx CPUID1_ECX.SSE4_1 and ecx 1 
idsse42 cpuid 1 shr ecx CPUID1_ECX.SSE4_2 and ecx 1 
idx2apic cpuid 1 shr ecx CPUID1_ECX.X2APIC and ecx 1 
idmovbe cpuid 1 shr ecx CPUID1_ECX.MOVBE and ecx 1 
idpopcnt cpuid 1 shr ecx CPUID1_ECX.POPCNT and ecx 1 
idtscd cpuid 1 shr ecx CPUID1_ECX.TSCD and ecx 1 
idaes cpuid 1 shr ecx CPUID1_ECX.AES and ecx 1 
idxsave cpuid 1 shr ecx CPUID1_ECX.XSAVE and ecx 1 
idosxsave cpuid 1 shr ecx CPUID1_ECX.OSXSAVE and ecx 1 
idavx cpuid 1 shr ecx CPUID1_ECX.AVX and ecx 1 
idf16c cpuid 1 shr ecx CPUID1_ECX.F16C and ecx 1 
idrdrand cpuid 1 shr ecx CPUID1_ECX.RDRAND and ecx 1 
idhv cpuid 1 shr ecx CPUID1_ECX.HV and ecx 1 
idfpu cpuid 1 shr edx CPUID1_EDX.FPU and edx 1 
idvme cpuid 1 shr edx CPUID1_EDX.VME and edx 1 
idde cpuid 1 shr edx CPUID1_EDX.DE and edx 1 
idpse cpuid 1 shr edx CPUID1_EDX.PSE and edx 1 
idtsc cpuid 1 shr edx CPUID1_EDX.TSC and edx 1 
idmsr cpuid 1 shr edx CPUID1_EDX.MSR and edx 1 
idpae cpuid 1 shr edx CPUID1_EDX.PAE and edx 1 
idcx8 cpuid 1 shr edx CPUID1_EDX.CX8 and edx 1 
idapic cpuid 1 shr edx CPUID1_EDX.APIC and edx 1 
idsep cpuid 1 shr edx CPUID1_EDX.SEP and edx 1 
idmtrr cpuid 1 shr edx CPUID1_EDX.MTRR and edx 1 
idpge cpuid 1 shr edx CPUID1_EDX.PGE and edx 1 
idmca cpuid 1 shr edx CPUID1_EDX.MCA and edx 1 
idcmov cpuid 1 shr edx CPUID1_EDX.CMOV and edx 1 
idpat cpuid 1 shr edx CPUID1_EDX.PAT and edx 1 
idpse36 cpuid 1 shr edx CPUID1_EDX.PSE36 and edx 1 
idpsn cpuid 1 shr edx CPUID1_EDX.PSN and edx 1 
idclfl cpuid 1 shr edx CPUID1_EDX.CLFL and edx 1 
idds cpuid 1 shr edx CPUID1_EDX.DS and edx 1 
idacpi cpuid 1 shr edx CPUID1_EDX.ACPI and edx 1 
idr64 cpuid 1 shr edx CPUID1_EDX.r64 and edx 1 
idfxsr cpuid 1 shr edx CPUID1_EDX.FXSR and edx 1 
idsse cpuid 1 shr edx CPUID1_EDX.NP and edx 1 
idsse2 cpuid 1 shr edx CPUID1_EDX.SSE2 and edx 1 
idss cpuid 1 shr edx CPUID1_EDX.SS and edx 1 
idhtt cpuid 1 shr edx CPUID1_EDX.HTT and edx 1 
idtm cpuid 1 shr edx CPUID1_EDX.TM and edx 1 
idia64 cpuid 1 shr edx CPUID1_EDX.IA64 and edx 1 
idpbe cpuid 1 shr edx CPUID1_EDX.PBE and edx 1 
/* ====== 3DNow! ====== */
// This is an AMD exclusive vector instruction set that uses MM registers.
// It has been deprecated and sucks do not use this for any kind of compiler generation.

pfadd r64 rm64 0 0x0f 0x0f $0 $1 0x9e 
pfsub r64 rm64 0 0x0f 0x0f $0 $1 0x9a 
pfsubr r64 rm64 0 0x0f 0x0f $0 $1 0xaa 
pfmul r64 rm64 0 0x0f 0x0f $0 $1 0xb4 

pfcmpeq r64 rm64 0 0x0f 0x0f $0 $1 0xb0 
pfcmpge r64 rm64 0 0x0f 0x0f $0 $1 0x90 
pfcmpgt r64 rm64 0 0x0f 0x0f $0 $1 0xa0 

pf2id r64 rm64 0 0x0f 0x0f $0 $1 0x1d 
pi2fd r64 rm64 0 0x0f 0x0f $0 $1 0x0d 
pf2iw r64 rm64 0 0x0f 0x0f $0 $1 0x1c 
pi2fw r64 rm64 0 0x0f 0x0f $0 $1 0x0c 

pfmax r64 rm64 0 0x0f 0x0f $0 $1 0xa4 
pfmin r64 rm64 0 0x0f 0x0f $0 $1 0x94 

pfrcp r64 rm64 0 0x0f 0x0f $0 $1 0x96 
pfrsqrt r64 rm64 0 0x0f 0x0f $0 $1 0x97 
pfrcpit1 r64 rm64 0 0x0f 0x0f $0 $1 0xa6 
pfrsqit1 r64 rm64 0 0x0f 0x0f $0 $1 0xa7 
pfrcpit2 r64 rm64 0 0x0f 0x0f $0 $1 0xb6 

pfacc r64 rm64 0 0x0f 0x0f $0 $1 0xae 
pfnacc r64 rm64 0 0x0f 0x0f $0 $1 0x8a 
pfpnacc r64 rm64 0 0x0f 0x0f $0 $1 0x8e 
pmulhrw r64 rm64 0 0x0f 0x0f $0 $1 0xb7 

pavgusb r64 rm64 0 0x0f 0x0f $0 $1 0xbf 
pswapd r64 rm64 0 0x0f 0x0f $0 $1 0xbb 
femms 0 0x0f 0x0e 
/* ====== ICEBP ====== */
// Intel exclusive interrupt instruction.
icebp 0 0xf1 
/* ====== PT ====== */

ptwrite rm rm32 4 0xf3 0x0f 0xae $0 
ptwrite rm rm64 4 0xf3 0x0f 0xae $0 
/* ====== CLWB ====== */

clwb rm rm8 6 0x66 0x0f 0xae $0 
/* ====== CLFLUSHOPT ====== */

clflushopt rm rm8 7 0x66 0x0f 0xae $0 
/* ====== SMAP ====== */
stac 0 0x0f 0x01 0xcb 
clac 0 0x0f 0x01 0xca 
/* ====== ADX ====== */

adc ubyte imm8 0 0x14 imm8 
adc ushort imm16 0 0x15 imm16 
adc uint imm32 0 0x15 imm32 

adc rm ubyte imm8 rm8 2 0x80 $0 imm8 
adc rm ushort imm16 rm16 2 0x81 $0 imm16 
adc rm uint imm32 rm32 2 0x81 $0 imm32 
adc rm uint imm32 rm64 2 0x81 $0 imm32 
adc rm ubyte imm8 rm16 2 0x83 $0 imm8 
adc rm ubyte imm8 rm32 2 0x83 $0 imm8 
adc rm ubyte imm8 rm64 2 0x83 $0 imm8 

adc rm R8 rm8 0 0x10 $0 $1 
adc rm R16 rm16 0 0x11 $0 $1 
adc rm R32 rm32 0 0x11 $0 $1 
adc rm R64 rm64 0 0x11 $0 $1 

adc R8 m8 0 0x12 $0 $1 
adc R16 m16 0 0x13 $0 $1 
adc R32 m32 0 0x13 $0 $1 
adc R64 m64 0 0x13 $0 $1 

adcx R32 rm32 0 0x0F 0x38 0xF6 $0 $1 
adcx R64 rm64 0 0x0F 0x38 0xF6 $0 $1 

adox R32 rm32 0 0xF3 0x0F 0x38 0xF6 $0 $1 
adox R64 rm64 0 0xF3 0x0F 0x38 0xF6 $0 $1 
/* ====== RDSEED ====== */

rdseed R16 7 0x0f 0xc7 $0 
rdseed R32 7 0x0f 0xc7 $0 
rdseed R64 7 0x0f 0xc7 $0 
/* ====== MPX ====== */

bndcl R32 rm32 0 0xf3 0x0f 0x1a $0 $1 
bndcl R64 rm64 0 0xf3 0x0f 0x1a $0 $1 

bndcu R32 rm32 0 0xf2 0x0f 0x1a $0 $1 
bndcu R64 rm64 0 0xf2 0x0f 0x1a $0 $1 

bndcn R32 rm32 0 0xf2 0x0f 0x1b $0 $1 
bndcn R64 rm64 0 0xf2 0x0f 0x1b $0 $1 

bndldx R64 rm64 /0 /rx 0x0f 0x1a $0 $1 
bnx rm R64 rm64 /0 /rx 0x0f 0x1b $0 $1 

bndmk R32 rm32 0 0xf3 0x0f 0x1b $0 $1 
bndmk R64 rm64 0 0xf3 0x0f 0x1b $0 $1 

bndmov R32 rm32 0 0x0f 0x1a $0 $1 
bndmov R64 rm64 0 0x0f 0x1a $0 $1 
bndmov m32 R32 0 0x0f 0x1b $0 $1 
bndmov m64 R32 0 0x0f 0x1b $0 $1 

bound R16 rm16 0 0x62 $0 $1 
bound R32 rm32 0 0x62 $0 $1 
/* ====== RTM ====== */
xend 0 0x0f 0x01 0xd5 
xabort ubyte imm8 0 0xc6 0xf8 imm8 
xbegin ushort rel16 0 0xc7 0xf8 rel16 
xbegin uint rel32 0 0xc7 0xf8 rel32 
xtest 0 0x0f 0x01 0xd6 
/* ====== INVPCID ====== */

invpcid R32 m128 0 0x0f 0x38 0x82 $0 $1 
invpcid R64 m128 0 0x0f 0x38 0x82 $0 $1 
/* ====== HLE ====== */

xacquire size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0xf2~buffer[ buffer.length - size ..$];
return size 1;
}

xacquire_lock size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0xf2~0xf0~buffer[ buffer.length - size ..$];
return size 2;
}

xrelease size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0xf3~buffer[ buffer.length - size ..$];
return size 1;
}
/* ====== BMI1 ====== */

tzcnt R16 rm16 0 0xf3 0x0f 0xbc $0 $1 
tzcnt R32 rm32 0 0xf3 0x0f 0xbc $0 $1 
tzcnt R64 rm64 0 0xf3 0x0f 0xbc $0 $1 

lzcnt R16 rm16 0 0xf3 0x0f 0xbd $0 $1 
lzcnt R32 rm32 0 0xf3 0x0f 0xbd $0 $1 
lzcnt R64 rm64 0 0xf3 0x0f 0xbd $0 $1 

andn R32 R32 rm rm32 /0 vex128.i [38] 0 0xf2 $0 $1 $2 
andn R64 R64 rm rm64 /0 vex128.i [38] 0 0xf2 $0 $1 $2 
/* ====== SGX ====== */
encls 0 0x0f 0x01 0xcf 
encls_ecreate mov eax 0 encls 
encls_eadd mov eax 1 encls 
encls_einit mov eax 2 encls 
encls_eremove mov eax 3 encls 
encls_edbgrd mov eax 4 encls 
encls_edbgwr mov eax 5 encls 
encls_eextend mov eax 6 encls 
encls_eldb mov eax 7 encls 
encls_eldu mov eax 8 encls 
encls_eblock mov eax 9 encls 
encls_epa mov eax 0xa encls 
encls_ewb mov eax 0xb encls 
encls_etrack mov eax 0xc encls 
encls_eaug mov eax 0xd encls 
encls_emodpr mov eax 0xe encls 
encls_emodt mov eax 0xf encls 
encls_erdinfo mov eax 0x10 encls 
encls_etrackc mov eax 0x11 encls 
encls_eldbc mov eax 0x12 encls 
encls_elduc mov eax 0x13 encls 
enclu 0 0x0f 0x01 0xd7 
enclu_ereport mov eax 0 enclu 
enclu_egetkey mov eax 1 enclu 
enclu_eenter mov eax 2 enclu 
enclu_eresume mov eax 3 enclu 
enclu_eexit mov eax 4 enclu 
enclu_eaccept mov eax 5 enclu 
enclu_emodpe mov eax 6 enclu 
enclu_eacceptcopy mov eax 7 enclu 
enclu_edeccssa mov eax 9 enclu 
enclv 0 0x0f 0x01 0xc0 
enclv_edecvirtchild mov eax 0 enclv 
enclv_eincvirtchild mov eax 1 enclv 
enclv_esetcontext mov eax 2 enclv 
/* ====== MON ====== */
monitor 0 0x0f 0x01 0xc8 
mwait 0 0x0f 0x01 0xc9 
/* ====== VMX ====== */

invvpid R32 m128 0 0x66 0x0f 0x38 0x81 $0 $1 
invvpid R64 m128 0 0x66 0x0f 0x38 0x81 $0 $1 
invept R32 m128 0 0x66 0x0f 0x38 0x80 $0 $1 
invept R64 m128 0 0x66 0x0f 0x38 0x80 $0 $1 
vmcall 0 0x0f 0x01 0xc1 
vmfunc 0 0x0f 0x01 0xd4 
vmclear rm rm64 6 0x66 0x0f 0xc7 $0 
vmlaunch 0 0x0f 0x01 0xc2 
vmresume 0 0x0f 0x01 0xc3 
vmxoff 0 0x0f 0x01 0xc4 
vmxon rm rm64 6 0xf3 0x0f 0xc7 $0 

vmwrite R32 rm32 /0 /rx 0x0f 0x79 $0 $1 
vmwrite R64 rm64 /0 /rx 0x0f 0x79 $0 $1 
vmread rm R32 rm32 /0 /rx 0x0f 0x78 $0 $1 
vmread rm R64 rm64 /0 /rx 0x0f 0x78 $0 $1 

vmptrst rm rm64 /7 /rx 0x0f 0xc7 $0 
vmptrld rm rm64 /6 /rx 0x0f 0xc7 $0 
/* ====== SMX ====== */
getsec 0 0x0f 0x37 
getsec_capabilities mov eax 0 getsec 
getsec_enteraccs mov eax 2 getsec 
getsec_exitac mov eax 3 getsec 
getsec_senter mov eax 4 getsec 
getsec_sexit mov eax 5 getsec 
getsec_parameters mov eax 6 getsec 
getsec_smctrl mov eax 7 getsec 
getsec_wakeup mov eax 8 getsec 
/* ====== CX16 ====== */

cmpxchg16b m128 1 0x48 0x0f 0xc7 $0 
/* ====== POPCNT ====== */

popcnt R16 rm16 0 0xf3 0x0f 0xb8 $0 $1 
popcnt R32 rm32 0 0xf3 0x0f 0xb8 $0 $1 
popcnt R64 rm64 0 0xf3 0x0f 0xb8 $0 $1 
/* ====== XSAVE ====== */
xgetbv 0 0x0f 0x01 0xd0 
xsetbv 0 0x0f 0x01 0xd1 

xrstor rm mxx /5 /rx 0x0f 0xae $0 
xsave rm mxx /4 /rx 0x0f 0xae $0 

xrstors rm mxx /3 /rx 0x0f 0xc7 $0 
xsaves rm mxx /5 /rx 0x0f 0xc7 $0 

xsaveopt rm mxx /6 /rx 0x0f 0xae $0 
xsavec rm mxx /4 /rx 0x0f 0xc7 $0 
/* ====== RDRAND ====== */

rdrand R16 6 0x0f 0xc7 $0 
rdrand R32 6 0x0f 0xc7 $0 
rdrand R64 6 0x0f 0xc7 $0 
/* ====== FPU ====== */
fabs 0 0xd9 0xe1 
fchs 0 0xd9 0xe0 
fclex 0 0x9b 0xdb 0xe2 
fnclex 0 0xdb 0xe2 

fadd m32 /0 /rx 0xd8 $0 
fadd m64 /0 /rx 0xdc $0 
fadd ST ST 
{
if .index == 0 
emit! /0 /e 0xd8 0xc0 $1 
else if .index == 0 
emit! /0 /e 0xdc 0xc0 $0 
else
assert /0 "Cannot encode 'fadd' with no 'st0' operand!" 
}
faddp ST /0 /e 0xde 0xc0 $0 
fiadd m16 /0 /rx 0xde $0 
fiadd m32 /0 /rx 0xda $0 

fbld m80 /4 /rx 0xdf $0 
fbstp m80 /6 /rx 0xdf $0 

fcom m32 /2 /rx 0xd8 $0 
fcom m64 /2 /rx 0xdc $0 
fcom ST /2 /e 0xd8 0xd0 $0 

fcomp m32 /3 /rx 0xd8 $0 
fcomp m64 /3 /rx 0xdc $0 
fcomp ST /2 /e 0xd8 0xd8 $0 
fcompp 0 0xde 0xd9 

fcomi ST /0 /e 0xdb 0xf0 $0 
fcomip ST /0 /e 0xdf 0xf0 $0 
fucomi ST /0 /e 0xdb 0xe8 $0 
fucomip ST /0 /e 0xdf 0xe8 $0 

ficom m16 /2 /rx 0xde $0 
ficom m32 /2 /rx 0xda $0 
ficomp m16 /2 /rx 0xde $0 
ficomp m32 /2 /rx 0xda $0 

fucom ST /2 /e 0xdd 0xe0 $0 
fucomp ST /2 /e 0xdd 0xe8 $0 
fucompp 0 0xda 0xe9 
ftst 0 0xd9 0xe4 
f2xm1 0 0xd9 0xf0 
fyl2x 0 0xd9 0xf1 
fyl2xp1 0 0xd9 0xf9 
fcos 0 0xd9 0xff 
fsin 0 0xd9 0xfe 
fsincos 0 0xd9 0xfb 
fsqrt 0 0xd9 0xfa 
fptan 0 0xd9 0xf2 
fpatan 0 0xd9 0xf3 
fprem 0 0xd9 0xf8 
fprem1 0 0xd9 0xf5 
fdecstp 0 0xd9 0xf6 
fincstp 0 0xd9 0xf7 

fild m16 /0 /rx 0xdf $0 
fild m32 /0 /rx 0xdb $0 
fild m64 /5 /rx 0xdf $0 

fist m16 /2 /rx 0xdf $0 
fist m32 /2 /rx 0xdb $0 

fistp m16 /3 /rx 0xdf $0 
fistp m32 /3 /rx 0xdb $0 
fistp m64 /7 /rx 0xdf $0 

fisttp m16 /1 /rx 0xdf $0 
fisttp m32 /1 /rx 0xdb $0 
fisttp m64 /1 /rx 0xdd $0 

fldcw m16 /5 /rx 0xd9 $0 
fstcw m16 /7 /rx 0x9b 0xd9 $0 
fnstcw m16 /7 /rx 0xd9 $0 

fldenv m112 /4 /rx 0xd9 $0 
fldenv m224 /4 /rx 0xd9 $0 

fstenv m112 /6 /rx 0x9b 0xd9 $0 
fstenv m224 /6 /rx 0x9b 0xd9 $0 

fnstenv m112 /6 /rx 0xd9 $0 
fnstenv m224 /6 /rx 0xd9 $0 

fstsw m16 /7 /rx 0x9b 0xdd $0 
fstsw 0 0x9b 0xdf 0xe0 
fnstsw m16 /7 /rx 0xdd $0 
fnstsw 0 0xdf 0xe0 

fld m32 /0 /rx 0xd9 $0 
fld m64 /0 /rx 0xdd $0 
fld m80 /5 /rx 0xdb $0 
fld ST /0 /e 0xd9 0xc0 $0 
fld1 0 0xd9 0xe8 
fldl2t 0 0xd9 0xe9 
fldl2e 0 0xd9 0xea 
fldpi 0 0xd9 0xeb 
fldlg2 0 0xd9 0xec 
fldln2 0 0xd9 0xed 
fldz 0 0xd9 0xee 

fst m32 /2 /rx 0xd9 $0 
fst m64 /2 /rx 0xdd $0 
fst ST /0 /e 0xdd 0xd0 $0 

fstp m32 /3 /rx 0xd9 $0 
fstp m64 /3 /rx 0xdd $0 
fstp m80 /7 /rx 0xdb $0 
fstp ST /0 /e 0xdd 0xd8 $0 

fdiv m32 /6 /rx 0xd8 $0 
fdiv m64 /6 /rx 0xdc $0 
fdiv ST ST 
{
if .index == 0 
emit! /0 /e 0xd8 0xf0 $1 
else if .index == 0 
emit! /0 /e 0xdc 0xf8 $0 
else
assert /0 "Cannot encode 'fadd' with no 'st0' operand!" 
}
fdivp ST /0 /e 0xde 0xf8 $0 
fidiv m16 /6 /rx 0xde $0 
fidiv m32 /6 /rx 0xda $0 

fdivr m32 /7 /rx 0xd8 $0 
fdivr m64 /7 /rx 0xdc $0 
fdivr ST ST 
{
if .index == 0 
emit! /0 /e 0xd8 0xf8 $1 
else if .index == 0 
emit! /0 /e 0xdc 0xf0 $0 
else
assert /0 "Cannot encode 'fadd' with no 'st0' operand!" 
}
fdivrp ST /0 /e 0xde 0xf0 $0 
fidivr m16 /7 /rx 0xde $0 
fidivr m32 /7 /rx 0xda $0 
fscale 0 0xd9 0xfd 
frndint 0 0xd9 0xfc 
fexam 0 0xd9 0xe5 
ffree ST /0 /e 0xdd 0xc0 $0 
fxch ST /0 /e 0xd9 0xc8 $0 
fxtract 0 0xd9 0xf4 
fnop 0 0xd9 0xd0 
fninit 0 0x9b 0xdb 0xe3 
finit 0 0xdb 0xe3 

fsave m752 6 0x9b 0xdd $0 
fsave m864 6 0x9b 0xdd $0 

fnsave m752 6 0xdd $0 
fnsave m864 6 0xdd $0 

frstor m752 4 0xdd $0 
frstor m864 4 0xdd $0 
static if !X64 
fxsave m4096 /0 /rx 0x0f 0xae $0 
static if X64 
fxsave m4096 /0 /rx 0x48 0x0f 0xae $0 
static if !X64 
fxrstor m4096 /1 /rx 0x0f 0xae $0 
static if X64 
fxrstor m4096 /1 /rx 0x48 0x0f 0xae $0 

fmul m32 /1 /rx 0xd8 $0 
fmul m64 /1 /rx 0xdc $0 
fmul ST ST 
{
if .index == 0 
emit! /0 /e 0xd8 0xc8 $1 
else if .index == 0 
emit! /0 /e 0xdc 0xc8 $0 
else
assert /0 "Cannot encode 'fadd' with no 'st0' operand!" 
}
fmulp ST /0 /e 0xde 0xc8 $0 
fimul m16 /1 /rx 0xde $0 
fimul m32 /1 /rx 0xda $0 

fsub m32 /4 /rx 0xd8 $0 
fsub m64 /4 /rx 0xdc $0 
fsub ST ST 
{
if .index == 0 
emit! /0 /e 0xd8 0xe0 $1 
else if .index == 0 
emit! /0 /e 0xdc 0xe8 $0 
else
assert /0 "Cannot encode 'fadd' with no 'st0' operand!" 
}
fsubp ST /0 /e 0xde 0xe8 $0 
fisub m16 /4 /rx 0xde $0 
fisub m32 /4 /rx 0xda $0 

fsubr m32 /5 /rx 0xd8 $0 
fsubr m64 /5 /rx 0xdc $0 
fsubr ST ST 
{
if .index == 0 
emit! /0 /e 0xd8 0xe8 $1 
else if .index == 0 
emit! /0 /e 0xdc 0xe0 $0 
else
assert /0 "Cannot encode 'fadd' with no 'st0' operand!" 
}
fsubrp ST /0 /e 0xde 0xe0 $0 
fisubr m16 /5 /rx 0xde $0 
fisubr m32 /5 /rx 0xda $0 

fcmovb ST /0 /e 0xda 0xc0 $0 
fcmove ST /0 /e 0xda 0xc8 $0 
fcmovbe ST /0 /e 0xda 0xd0 $0 
fcmovu ST /0 /e 0xda 0xd8 $0 
fcmovnb ST /0 /e 0xdb 0xc0 $0 
fcmovne ST /0 /e 0xdb 0xc8 $0 
fcmovnbe ST /0 /e 0xdb 0xd0 $0 
fcmovnu ST /0 /e 0xdb 0xd8 $0 
/* ====== TSC ====== */
rdtsc 0 0x0f 0x31 
rdtscp 0 0x0f 0x01 0xf9 
/* ====== MSR ====== */
rdmsr 0 0x0f 0x32 
wrmsr 0 0x0f 0x30 
/* ====== CX8 ====== */

cmpxchg8b m64 /1 /rx 0x0f 0xc7 $0 
/* ====== SEP ====== */
sysenter 0 0x0f 0x34 
sysexitc 0 0x0f 0x35 
sysexit 0 0x0f 0x35 
/* ====== CMOV ====== */

cmova R16 rm16 0 0x0f 0x47 $0 $1 
cmova R32 rm32 0 0x0f 0x47 $0 $1 
cmova R64 rm64 0 0x0f 0x47 $0 $1 

cmovae R16 rm16 0 0x0f 0x43 $0 $1 
cmovae R32 rm32 0 0x0f 0x43 $0 $1 
cmovae R64 rm64 0 0x0f 0x43 $0 $1 

cmovb R16 rm16 0 0x0f 0x42 $0 $1 
cmovb R32 rm32 0 0x0f 0x42 $0 $1 
cmovb R64 rm64 0 0x0f 0x42 $0 $1 

cmovbe R16 rm16 0 0x0f 0x46 $0 $1 
cmovbe R32 rm32 0 0x0f 0x46 $0 $1 
cmovbe R64 rm64 0 0x0f 0x46 $0 $1 

cmovc R16 rm16 0 0x0f 0x42 $0 $1 
cmovc R32 rm32 0 0x0f 0x42 $0 $1 
cmovc R64 rm64 0 0x0f 0x42 $0 $1 

cmove R16 rm16 0 0x0f 0x44 $0 $1 
cmove R32 rm32 0 0x0f 0x44 $0 $1 
cmove R64 rm64 0 0x0f 0x44 $0 $1 

cmovg R16 rm16 0 0x0f 0x4f $0 $1 
cmovg R32 rm32 0 0x0f 0x4f $0 $1 
cmovg R64 rm64 0 0x0f 0x4f $0 $1 

cmovge R16 rm16 0 0x0f 0x4d $0 $1 
cmovge R32 rm32 0 0x0f 0x4d $0 $1 
cmovge R64 rm64 0 0x0f 0x4d $0 $1 

cmovl R16 rm16 0 0x0f 0x4c $0 $1 
cmovl R32 rm32 0 0x0f 0x4c $0 $1 
cmovl R64 rm64 0 0x0f 0x4c $0 $1 

cmovle R16 rm16 0 0x0f 0x4e $0 $1 
cmovle R32 rm32 0 0x0f 0x4e $0 $1 
cmovle R64 rm64 0 0x0f 0x4e $0 $1 

cmovna R16 rm16 0 0x0f 0x46 $0 $1 
cmovna R32 rm32 0 0x0f 0x46 $0 $1 
cmovna R64 rm64 0 0x0f 0x46 $0 $1 

cmovnae R16 rm16 0 0x0f 0x42 $0 $1 
cmovnae R32 rm32 0 0x0f 0x42 $0 $1 
cmovnae R64 rm64 0 0x0f 0x42 $0 $1 

cmovnb R16 rm16 0 0x0f 0x43 $0 $1 
cmovnb R32 rm32 0 0x0f 0x43 $0 $1 
cmovnb R64 rm64 0 0x0f 0x43 $0 $1 

cmovnbe R16 rm16 0 0x0f 0x47 $0 $1 
cmovnbe R32 rm32 0 0x0f 0x47 $0 $1 
cmovnbe R64 rm64 0 0x0f 0x47 $0 $1 

cmovnc R16 rm16 0 0x0f 0x43 $0 $1 
cmovnc R32 rm32 0 0x0f 0x43 $0 $1 
cmovnc R64 rm64 0 0x0f 0x43 $0 $1 

cmovne R16 rm16 0 0x0f 0x45 $0 $1 
cmovne R32 rm32 0 0x0f 0x45 $0 $1 
cmovne R64 rm64 0 0x0f 0x45 $0 $1 

cmovng R16 rm16 0 0x0f 0x4e $0 $1 
cmovng R32 rm32 0 0x0f 0x4e $0 $1 
cmovng R64 rm64 0 0x0f 0x4e $0 $1 

cmovnge R16 rm16 0 0x0f 0x4c $0 $1 
cmovnge R32 rm32 0 0x0f 0x4c $0 $1 
cmovnge R64 rm64 0 0x0f 0x4c $0 $1 

cmovnl R16 rm16 0 0x0f 0x4d $0 $1 
cmovnl R32 rm32 0 0x0f 0x4d $0 $1 
cmovnl R64 rm64 0 0x0f 0x4d $0 $1 

cmovnle R16 rm16 0 0x0f 0x4f $0 $1 
cmovnle R32 rm32 0 0x0f 0x4f $0 $1 
cmovnle R64 rm64 0 0x0f 0x4f $0 $1 

cmovno R16 rm16 0 0x0f 0x41 $0 $1 
cmovno R32 rm32 0 0x0f 0x41 $0 $1 
cmovno R64 rm64 0 0x0f 0x41 $0 $1 

cmovnp R16 rm16 0 0x0f 0x4b $0 $1 
cmovnp R32 rm32 0 0x0f 0x4b $0 $1 
cmovnp R64 rm64 0 0x0f 0x4b $0 $1 

cmovns R16 rm16 0 0x0f 0x49 $0 $1 
cmovns R32 rm32 0 0x0f 0x49 $0 $1 
cmovns R64 rm64 0 0x0f 0x49 $0 $1 

cmovnz R16 rm16 0 0x0f 0x45 $0 $1 
cmovnz R32 rm32 0 0x0f 0x45 $0 $1 
cmovnz R64 rm64 0 0x0f 0x45 $0 $1 

cmovo R16 rm16 0 0x0f 0x40 $0 $1 
cmovo R32 rm32 0 0x0f 0x40 $0 $1 
cmovo R64 rm64 0 0x0f 0x40 $0 $1 

cmovp R16 rm16 0 0x0f 0x4a $0 $1 
cmovp R32 rm32 0 0x0f 0x4a $0 $1 
cmovp R64 rm64 0 0x0f 0x4a $0 $1 

cmovpe R16 rm16 0 0x0f 0x4a $0 $1 
cmovpe R32 rm32 0 0x0f 0x4a $0 $1 
cmovpe R64 rm64 0 0x0f 0x4a $0 $1 

cmovpo R16 rm16 0 0x0f 0x4b $0 $1 
cmovpo R32 rm32 0 0x0f 0x4b $0 $1 
cmovpo R64 rm64 0 0x0f 0x4b $0 $1 

cmovs R16 rm16 0 0x0f 0x48 $0 $1 
cmovs R32 rm32 0 0x0f 0x48 $0 $1 
cmovs R64 rm64 0 0x0f 0x48 $0 $1 

cmovz R16 rm16 0 0x0f 0x44 $0 $1 
cmovz R32 rm32 0 0x0f 0x44 $0 $1 
cmovz R64 rm64 0 0x0f 0x44 $0 $1 
/* ====== CLFL ====== */

clflush rm rm8 /7 /rx 0x0f 0xae $0 
/* ====== HRESET ====== */

hreset ubyte imm8 0 0xf/3 0x0f 0x3a 0xf/0 0xc0 imm8 eax 
/* ====== CET ====== */
// Shadow stack instruction set.

incsspd R32 5 0xf3 0x0f 0xae $0 
incsspq R64 5 0xf3 0x0f 0xae $0 

clrssbsy m64 6 0xf3 0x0f 0xae $0 
setssbsy 0 0xf3 0x0f 0x01 0xe8 

rdsspd R32 1 0xf3 0x0f 0x1e $0 
rdsspq R64 1 0xf3 0x0f 0x1e $0 

wrssd m32 R32 0 0xf3 0x38 0xf6 $0 $1 
wrssq m64 R64 0 0xf3 0x38 0xf6 $0 $1 

wrussd m32 R32 1 0x6/6 0xf3 0x38 0xf5 $0 $1 
wrussq m64 R64 1 0x6/6 0xf3 0x38 0xf5 $0 $1 

rstorssp m64 5 0xf3 0x0f 0x01 $0 
saveprevssp 5 0xf3 0x0f 0x01 0xae edx 
endbr32 0 0xf3 0x0f 0x1e 0xfb 
endbr64 0 0xf3 0x0f 0x1e 0xfa 
/* ====== FSGSBASE ====== */

rdfsbase R32 0 0xf3 0x0f 0xae $0 
rdfsbase R64 0 0xf3 0x0f 0xae $0 

rdgsbase R32 1 0xf3 0x0f 0xae $0 
rdgsbase R64 1 0xf3 0x0f 0xae $0 

wrfsbase R32 2 0xf3 0x0f 0xae $0 
wrfsbase R64 2 0xf3 0x0f 0xae $0 

wrgsbase R32 3 0xf3 0x0f 0xae $0 
wrgsbase R64 3 0xf3 0x0f 0xae $0 
/* ====== RDPID ====== */

rdpid R32 7 0xf3 0x0f 0xc7 $0 
rdpid R64 7 0xf3 0x0f 0xc7 $0 
/* ====== OSPKE ====== */
wrpkru 0 0x0f 0x01 0xef 
rdpkru 0 0x0f 0x01 0xee 
/* ====== UINTR ====== */
testui 0 0xf3 0x0f 0x01 0xed 
stui 0 0xf3 0x0f 0x01 0xef 
clui 0 0xf3 0x0f 0x01 0xee 
uiret 0 0xf3 0x0f 0x01 0xec 

senduipi rm rm8 6 0xf3 0x0f 0xc7 $0 
senduipi rm rm16 6 0xf3 0x0f 0xc7 $0 
senduipi rm rm32 6 0xf3 0x0f 0xc7 $0 
senduipi rm rm64 6 0xf3 0x0f 0xc7 $0 
/* ====== WAITPKG ====== */

umwait R32 6 0xf2 0x0f 0xae $0 
umonitor R16 6 0xf3 0x0f 0xae $0 
umonitor R32 6 0xf3 0x0f 0xae $0 
umonitor R64 6 0xf3 0x0f 0xae $0 
tpause R32 6 0x0f 0xae $0 
/* ====== CLDEMOTE ====== */

cldemote rm rm8 0 0x0f 0x1c $0 
/* ====== TSXLDTRK ====== */
xresldtrk 0 0xf2 0x0f 0x01 0xe9 
xsusldtrk 0 0xf2 0x0f 0x01 0xe8 
/* ====== SERALIZE ====== */
serialize 0 0x0f 0x01 0xe8 
/* ====== PCONFIG ====== */
pconfig 0 0x0f 0x01 0xc5 
/* ====== PMC ====== */
rdpmc 0 0x0f 0x33 
/* ====== UMIP ====== */
wbinvd 0 0x0f 0x09 
wbnoinvd 0 0xf3 0x0f 0x09 
invd 0 0x0f 0x08 

lgdt rm rm32 2 0x0f 0x01 $0 
lgdt rm rm64 2 0x0f 0x01 $0 
sgdt rm rm64 0 0x0f 0x01 $0 

lldt rm rm16 2 0x0f 0x00 $0 
sldt rm rm16 0 0x0f 0x00 $0 

lidt rm rm32 3 0x0f 0x01 $0 
lidt rm rm64 3 0x0f 0x01 $0 
sidt rm rm64 1 0x0f 0x01 $0 

lmsw rm rm16 6 0x0f 0x01 $0 

smsw rm rm16 4 0x0f 0x01 $0 
smsw rm rm32 4 0x0f 0x01 $0 
smsw rm rm64 4 0x0f 0x01 $0 
/* ====== PCID ====== */

invlpg rm rm64 7 0x0f 0x01 $0 
/* ====== LAHF-SAHF ====== */
sahf 0 0x9e 
lahf 0 0x9f 
/* ====== BMI2 ====== */
sarx R32 rm R32 rm32 /0 vex128.i [38] 0xf3 0xf7 $0 $1 
shlx R32 rm R32 rm32 /0 vex128.i [38] 0x66p 0xf7 $0 $1 
shrx R32 rm R32 rm32 /0 vex128.i [38] 0xf2 0xf7 $0 $1 
sarx R64 rm R64 rm64 /0 vex128.i [38] 0xf3 0xf7 $0 $1 
shlx R64 rm R64 rm64 /0 vex128.i [38] 0x66p 0xf7 $0 $1 
shrx R64 rm R64 rm64 /0 vex128.i [38] 0xf2 0xf7 $0 $1 
/* ====== r64 ====== */
movq r64 rm64 /0 /rx /f 0x0f 0x6f $0 $1 
movq m64 r64 /0 /rx /f 0x0f 0x7f $0 $1 
movd r64 rm32 /0 /rx /f 0x0f 0x6e $0 $1 
movd rm r64 rm32 /0 /rx /f 0x0f 0x7e $0 $1 
movq r64 rm64 0 0x0f 0x6e $0 $1 
movq rm r64 rm64 0 0x0f 0x7e $0 $1 
/* ====== /rx /f ====== */
addpd r128 rm128 /0 /rx /f 0x66 0x0f 0x58 $0 $1 
addps r128 rm128 /0 /rx /f 0x0f 0x58 $0 $1 
addss r128 rm 12832 /0 /rx /f 0xf3 0x0f 0x58 $0 $1 
addsd r128 rm 12832 /0 /rx /f 0xf2 0x0f 0x58 $0 $1 
/* ====== SSE2 ====== */
lfence 0 0x0f 0xae 0xe8 
sfence 0 0x0f 0xae 0xf8 
mfence 0 0x0f 0xae 0xf0 
movq r128 rm 12864 /0 /rx /f 0xf3 0x0f 0x7e $0 $1 
movq m64 r128 /0 /rx /f 0x66 0x0f 0xd6 $0 $1 
movd r128 rm32 /0 /rx /f 0x66 0x0f 0x6e $0 $1 
movd rm r128 rm32 /0 /rx /f 0x66 0x0f 0x7e $0 $1 
// TODO: This won't flip and but should also also should generate a REX
movq r128 rm64 0 0x66 0x0f 0x6e $0 $1 
movq rm r128 rm64 0 0x66 0x0f 0x7e $0 $1 
/* ====== SSE3 ====== */
addsubps r128 rm128 /0 /rx /f 0xf2 0x0f 0xd0 $0 $1 
addsubpd r128 rm128 /0 /rx /f 0x66 0x0f 0xd0 $0 $1 
/* ====== AVX ====== */
vaddpd r128 r128 rm rm128 /0 vex128 0x66p 0x58 $0 $1 $2 
vaddpd r256 r256 rm rm256 /0 vex256 0x66p 0x58 $0 $1 $2 
vaddps r128 r128 rm rm128 /0 vex128 0x58 $0 $1 $2 
vaddps r256 r256 rm rm256 /0 vex256 0x58 $0 $1 $2 
vaddsd r128 r128 rm rm 12864 /0 vex128xf2 0x58 $0 $1 $2 
vaddss r128 r128 rm rm 12832 /0 vex128xf3 0x58 $0 $1 $2 
vaddsubpd r128 r128 rm rm128 /0 vex128 0x66p 0xd0 $0 $1 $2 
vaddsubpd r256 r256 rm rm256 /0 vex256 0x66p 0xd0 $0 $1 $2 
vaddsubps r128 r128 rm rm128 /0 vex128xf2 0xd0 $0 $1 $2 
vaddsubps r256 r256 rm rm256 /0 vex256xf2 0xd0 $0 $1 $2 
vmovq r128 rm 12864 /0 vex128xf3 0x7e $0 $1 
vmovq m64 r128 /0 vex128 0x66p 0xd6 $0 $1 

vmovd r128 rm32 /0 vex128 0x66p 0x6e $0 $1 
vmovd rm r128 rm32 /0 vex128 0x66p 0x7e $0 $1 

vmovq r128 rm64 /0 vex128 0x66p 0x6e $0 $1 
vmovq rm r128 rm64 /0 vex128 0x66p 0x7e $0 $1 
/* ====== AES ====== */

aesdec r128 rm128 /0 /rx /f 0x66 0x0f 0x38 0xde $0 $1 
vaesdec r128 r128 rm rm128 /0 vex128 [38] 0x66p 0xde $0 $1 $2 
vaesdec r256 r256 rm rm256 /0 vex256 [38] 0x66p 0xde $0 $1 $2 
aesdec128kl r128 m384 /0 /rx /f 0xf3 0x0f 0x38 0xdd $0 $1 
aesdec256kl r128 m512 /0 /rx /f 0xf3 0x0f 0x38 0xdf $0 $1 

aesdeclast r128 rm128 /0 /rx /f 0x66 0x0f 0x38 0xdf $0 $1 
vaesdeclast r128 r128 rm rm128 /0 vex128 [38] 0x66p 0xdf $0 $1 $2 
vaesdeclast r256 r256 rm rm256 /0 vex256 [38] 0x66p 0xdf $0 $1 $2 
aesdecwide128kl m384 /0 /rx /f 0xf3 0x0f 0x38 0xd8 $0 ecx 
aesdecwide256kl m512 /0 /rx /f 0xf3 0x0f 0x38 0xd8 $0 ebx 

aesenc r128 rm128 /0 /rx /f 0x66 0x0f 0x38 0xdc $0 $1 
vaesenc r128 r128 rm rm128 /0 vex128 [38] 0x66p 0xdc $0 $1 $2 
vaesenc r256 r256 rm rm256 /0 vex256 [38] 0x66p 0xdc $0 $1 $2 
aesenc128kl r128 m384 /0 /rx /f 0xf3 0x0f 0x38 0xdc $0 $1 
aesenc256kl r128 m512 /0 /rx /f 0xf3 0x0f 0x38 0xde $0 $1 

aesenclast r128 rm128 /0 /rx /f 0x66 0x0f 0x38 0xdd $0 $1 
vaesenclast r128 r128 rm rm128 /0 vex128 [38] 0x66p 0xdd $0 $1 $2 
vaesenclast r256 r256 rm rm256 /0 vex256 [38] 0x66p 0xdd $0 $1 $2 
aesencwide128kl m384 /0 /rx /f 0xf3 0x0f 0x38 0xd8 $0 eax 
aesencwide256kl m512 /0 /rx /f 0xf3 0x0f 0x38 0xd8 $0 edx 

aesimc r128 rm128 /0 /rx /f 0x66 0x0f 0x38 0xdb $0 $1 
vaesimc r128 rm128 /0 vex128 [38] 0x66p 0xdb $0 $1 

aeskeygenassist r128 rm ubyte imm8 rm128 /0 /rx /f 0x66 0x0f 0x3a 0xdf $0 $1 imm8 
vaeskeygenassist r128 rm ubyte imm8 rm128 /0 vex128 [3a] 0x66p 0xdf $0 $1 imm8 
/* ====== SHA ====== */

sha1msg1 r128 rm128 /0 /rx /f 0x0f 0x38 0xc9 $0 $1 
sha1msg2 r128 rm128 /0 /rx /f 0x0f 0x38 0xca $0 $1 
sha1nexte r128 rm128 /0 /rx /f 0x0f 0x38 0xc8 $0 $1 

sha256msg1 r128 rm128 /0 /rx /f 0x0f 0x38 0xcc $0 $1 

sha1rnds4 r128 rm ubyte imm8 rm128 /0 /rx /f 0x0f 0x3a 0xcc $0 $1 imm8 

sha256rnds2 r128 rm128 /0 /rx /f 0x0f 0x38 0xcb $0 $1 
/* ====== MAIN ====== */
// NOTE: Branch hints are generally useless in the modern day AMD CPUs don't even acknowledge them;
// and thus these should not be used on any modern CPU.

not_taken size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0x2e~buffer[ buffer.length - size ..$];
return size 1;
}

taken size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0x3e~buffer[ buffer.length - size ..$];
return size 1;
}

crc32 R32 rm8 0 0xf2 0x0f 0x38 0xf0 $0 $1 
crc32 R32 rm16 0 0xf2 0x0f 0x38 0xf1 $0 $1 
crc32 R32 rm32 0 0xf2 0x0f 0x38 0xf1 $0 $1 

crc32 R64 rm8 0 0xf2 0x0f 0x38 0xf0 $0 $1 
crc32 R64 rm64 0 0xf2 0x0f 0x38 0xf1 $0 $1 
// literally 1984
// Why did I write this comment? What is literally 1984????
enqcmd R32 m512 0 0xf2 0x0f 0x38 0xf8 $0 $1 
enqcmd R64 m512 0 0xf2 0x0f 0x38 0xf8 $0 $1 

cmpxchg rm R8 rm8 0 0x0f 0xb0 $0 $1 
cmpxchg rm R16 rm16 0 0x0f 0xb1 $0 $1 
cmpxchg rm R32 rm32 0 0x0f 0xb1 $0 $1 
cmpxchg rm R64 rm64 0 0x0f 0xb1 $0 $1 
aaa 0 0x37 
aad 0 0xd5 0x0a 
aad ubyte imm8 0 0xd5 imm8 
aam 0 0xd4 0x0a 
aam ubyte imm8 0 0xd4 imm8 
aas 0 0x3f 

add ubyte imm8 0 0x04 imm8 
add ushort imm16 0 0x05 imm16 
add uint imm32 0 0x05 imm32 

add rm ubyte imm8 rm8 0 0x80 $0 imm8 
add rm ushort imm16 rm16 0 0x81 $0 imm16 
add rm uint imm32 rm32 0 0x81 $0 imm32 
add rm uint imm32 rm64 0 0x81 $0 imm32 
add rm ubyte imm8 rm16 0 0x83 $0 imm8 
add rm ubyte imm8 rm32 0 0x83 $0 imm8 
add rm ubyte imm8 rm64 0 0x83 $0 imm8 

add rm R8 rm8 0 0x00 $0 $1 
add rm R16 rm16 0 0x01 $0 $1 
add rm R32 rm32 0 0x01 $0 $1 
add rm R64 rm64 0 0x01 $0 $1 

add R8 m8 0 0x02 $0 $1 
add R16 m16 0 0x03 $0 $1 
add R32 m32 0 0x03 $0 $1 
add R64 m64 0 0x03 $0 $1 

and ubyte imm8 0 0x24 imm8 
and ushort imm16 0 0x25 imm16 
and uint imm32 0 0x25 imm32 

and rm ubyte imm8 rm8 4 0x80 $0 imm8 
and rm ushort imm16 rm16 4 0x81 $0 imm16 
and rm uint imm32 rm32 4 0x81 $0 imm32 
and rm uint imm32 rm64 4 0x81 $0 imm32 
and rm ubyte imm8 rm16 4 0x83 $0 imm8 
and rm ubyte imm8 rm32 4 0x83 $0 imm8 
and rm ubyte imm8 rm64 4 0x83 $0 imm8 

and rm R8 rm8 0 0x20 $0 $1 
and rm R16 rm16 0 0x21 $0 $1 
and rm R32 rm32 0 0x21 $0 $1 
and rm R64 rm64 0 0x21 $0 $1 

and R8 m8 0 0x22 $0 $1 
and R16 m16 0 0x23 $0 $1 
and R32 m32 0 0x23 $0 $1 
and R64 m64 0 0x23 $0 $1 

arpl rm R16 rm16 0 0x63 $0 $1 

bsf R16 rm16 0 0x0f 0xbc $0 $1 
bsf R32 rm32 0 0x0f 0xbc $0 $1 
bsf R64 rm64 0 0x0f 0xbc $0 $1 

bsr R16 rm16 0 0x0f 0xbd $0 $1 
bsr R32 rm32 0 0x0f 0xbd $0 $1 
bsr R64 rm64 0 0x0f 0xbd $0 $1 

bswap R32 /0 /e 0x0f 0xc8 $0 
bswap R64 /0 /e 0x0f 0xc8 $0 

bt rm R16 rm16 0 0x0f 0xa3 $0 $1 
bt rm R32 rm32 0 0x0f 0xa3 $0 $1 
bt rm R64 rm64 0 0x0f 0xa3 $0 $1 
bt rm ubyte imm8 rm16 4 0x0f 0xba $0 imm8 
bt rm ubyte imm8 rm32 4 0x0f 0xba $0 imm8 
bt rm ubyte imm8 rm64 4 0x0f 0xba $0 imm8 

btc rm R16 rm16 0 0x0f 0xbb $0 $1 
btc rm R32 rm32 0 0x0f 0xbb $0 $1 
btc rm R64 rm64 0 0x0f 0xbb $0 $1 
btc rm ubyte imm8 rm16 7 0x0f 0xba $0 imm8 
btc rm ubyte imm8 rm32 7 0x0f 0xba $0 imm8 
btc rm ubyte imm8 rm64 7 0x0f 0xba $0 imm8 

btr rm R16 rm16 0 0x0f 0xb3 $0 $1 
btr rm R32 rm32 0 0x0f 0xb3 $0 $1 
btr rm R64 rm64 0 0x0f 0xb3 $0 $1 
btr rm ubyte imm8 rm16 6 0x0f 0xba $0 imm8 
btr rm ubyte imm8 rm32 6 0x0f 0xba $0 imm8 
btr rm ubyte imm8 rm64 6 0x0f 0xba $0 imm8 

bts rm R16 rm16 0 0x0f 0xab $0 $1 
bts rm R32 rm32 0 0x0f 0xab $0 $1 
bts rm R64 rm64 0 0x0f 0xab $0 $1 
bts rm ubyte imm8 rm16 5 0x0f 0xba $0 imm8 
bts rm ubyte imm8 rm32 5 0x0f 0xba $0 imm8 
bts rm ubyte imm8 rm64 5 0x0f 0xba $0 imm8 

cmp ubyte imm8 0 0x3c imm8 
cmp ushort imm16 0 0x3d imm16 
cmp uint imm32 0 0x3d imm32 

cmp rm ubyte imm8 rm8 7 0x80 $0 imm8 
cmp rm ushort imm16 rm16 7 0x81 $0 imm16 
cmp rm uint imm32 rm32 7 0x81 $0 imm32 
cmp rm uint imm32 rm64 7 0x81 $0 imm32 
cmp rm ubyte imm8 rm16 7 0x83 $0 imm8 
cmp rm ubyte imm8 rm32 7 0x83 $0 imm8 
cmp rm ubyte imm8 rm64 7 0x83 $0 imm8 

cmp rm R8 rm8 0 0x38 $0 $1 
cmp rm R16 rm16 0 0x39 $0 $1 
cmp rm R32 rm32 0 0x39 $0 $1 
cmp rm R64 rm64 0 0x39 $0 $1 

cmp R8 m8 0 0x3a $0 $1 
cmp R16 m16 0 0x3b $0 $1 
cmp R32 m32 0 0x3b $0 $1 
cmp R64 m64 0 0x3b $0 $1 
cwd 0 0x66 0x99 
cdq 0 0x99 
cqo 0 0x48 0x99 
cbw 0 0x66 0x98 
cwde 0 0x98 
cdqe 0 0x48 0x98 
cpuid 0 0x0f 0xa2 
cpuid uint imm32 mov eax imm32 cpuid 
clc 0 0xf8 
cld 0 0xfc 
cli 0 0xfa 
clts 0 0x0f 0x06 
cmc 0 0xf5 

dec rm rm8 1 0xfe $0 
static if X64 
dec rm rm16 1 0xff $0 
static if !X64 
dec m16 1 0xff $0 
static if X64 
dec rm rm32 1 0xff $0 
static if !X64 
dec m32 1 0xff $0 
dec rm rm64 1 0xff $0 
static if !X64 
dec R16 /0 /e 0x48 $0 
static if !X64 
dec R32 /0 /e 0x48 $0 
int3 0 0xcc 
_int ubyte imm8 0 0xcd imm8 
into 0 0xce 
int1 0 0xf1 
ud0 R32 rm32 0 0x0f 0xff $0 $1 
ud1 R32 rm32 0 0x0f 0xb9 $0 $1 
ud2 0 0x0f 0x0b 
iret 0 0xcf 
iretd 0 0xcf 
iretq 0 0xcf 

inc rm rm8 0 0xfe $0 
static if X64 
inc rm rm16 0 0xff $0 
static if !X64 
inc m16 0 0xff $0 
static if X64 
inc rm rm32 0 0xff $0 
static if !X64 
inc m32 0 0xff $0 
inc rm rm64 0 0xff $0 
static if !X64 
inc R16 /0 /e 0x40 $0 
static if !X64 
inc R32 /0 /e 0x40 $0 
hlt 0 0xf4 
pause 0 0xf3 0x90 
swapgs 0 0x0f 0x01 0xf8 

lock size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0xf0~buffer[ buffer.length - size ..$];
return size 1;
}
wait 0 0x9b 
fwait 0 0x9b 
sysretc 0 0x0f 0x07 
sysret 0 0x0f 0x07 
syscall 0 0x0f 0x05 
rsm 0 0x0f 0xaa 
leave 0 0xc9 
enter ushort imm16 0 0xc8 imm16 0x00 
enter ushort imm1/6 ubyte imm8 0 0xc8 imm16 imm8 

lea R16 m16 0 0x8d $0 $1 
lea R32 m32 0 0x8d $0 $1 
lea R64 m64 0 0x8d $0 $1 

lds R16 m16 0 0xc5 $0 $1 
lds R32 m32 0 0xc5 $0 $1 

lss R16 m16 0 0x0f 0xb2 $0 $1 
lss R32 m32 0 0x0f 0xb2 $0 $1 
lss R64 m64 0 0x0f 0xb2 $0 $1 

les R16 m16 0 0xc4 $0 $1 
les R32 m32 0 0xc4 $0 $1 

lfs R16 m16 0 0x0f 0xb4 $0 $1 
lfs R32 m32 0 0x0f 0xb4 $0 $1 
lfs R64 m64 0 0x0f 0xb4 $0 $1 

lgs R16 m16 0 0x0f 0xb5 $0 $1 
lgs R32 m32 0 0x0f 0xb5 $0 $1 
lgs R64 m64 0 0x0f 0xb5 $0 $1 

lsl R16 rm16 0 0x0f 0x03 $0 $1 
lsl R32 R32 0 0x0f 0x03 $0 $1 
lsl R64 R32 0 0x0f 0x03 $0 $1 
lsl R32 m16 0 0x0f 0x03 $0 $1 
lsl R64 m16 0 0x0f 0x03 $0 $1 

ltr rm rm16 3 0x0f 0x00 $0 
str rm rm16 1 0x0f 0x00 $0 

neg rm rm8 3 0xf6 $0 
neg rm rm16 3 0xf7 $0 
neg rm rm32 3 0xf7 $0 
neg rm rm64 3 0xf7 $0 
nop 0 0x90 
nop rm rm16 0 0x0f 0x1f $0 

not rm rm8 2 0xf6 $0 
not rm rm16 2 0xf7 $0 
not rm rm32 2 0xf7 $0 
not rm rm64 2 0xf7 $0 
ret 0 0xc3 
ret ushort imm16 0 0xc2 imm16 
retf 0 0xcb 
retf ushort imm16 0 0xca imm16 
stc 0 0xf9 
std 0 0xfd 
sti 0 0xfb 

sub ubyte imm8 0 0x2c imm8 
sub ushort imm16 0 0x2d imm16 
sub uint imm32 0 0x2d imm32 

sub rm ubyte imm8 rm8 5 0x80 $0 imm8 
sub rm ushort imm16 rm16 5 0x81 $0 imm16 
sub rm uint imm32 rm32 5 0x81 $0 imm32 
sub rm uint imm32 rm64 5 0x81 $0 imm32 
sub rm ubyte imm8 rm16 5 0x83 $0 imm8 
sub rm ubyte imm8 rm32 5 0x83 $0 imm8 
sub rm ubyte imm8 rm64 5 0x83 $0 imm8 

sub rm R8 rm8 0 0x28 $0 $1 
sub rm R16 rm16 0 0x29 $0 $1 
sub rm R32 rm32 0 0x29 $0 $1 
sub rm R64 rm64 0 0x29 $0 $1 

sub R8 m8 0 0x2a $0 $1 
sub R16 m16 0 0x2b $0 $1 
sub R32 m32 0 0x2b $0 $1 
sub R64 m64 0 0x2b $0 $1 

sbb ubyte imm8 0 0x1c imm8 
sbb ushort imm16 0 0x1d imm16 
sbb uint imm32 0 0x1d imm32 

sbb rm ubyte imm8 rm8 3 0x80 $0 imm8 
sbb rm ushort imm16 rm16 3 0x81 $0 imm16 
sbb rm uint imm32 rm32 3 0x81 $0 imm32 
sbb rm uint imm32 rm64 3 0x81 $0 imm32 
sbb rm ubyte imm8 rm16 3 0x83 $0 imm8 
sbb rm ubyte imm8 rm32 3 0x83 $0 imm8 
sbb rm ubyte imm8 rm64 3 0x83 $0 imm8 

sbb rm R8 rm8 0 0x18 $0 $1 
sbb rm R16 rm16 0 0x19 $0 $1 
sbb rm R32 rm32 0 0x19 $0 $1 
sbb rm R64 rm64 0 0x19 $0 $1 

sbb R8 m8 0 0x1a $0 $1 
sbb R16 m16 0 0x1b $0 $1 
sbb R32 m32 0 0x1b $0 $1 
sbb R64 m64 0 0x1b $0 $1 

xor ubyte imm8 0 0x34 imm8 
xor ushort imm16 0 0x35 imm16 
xor uint imm32 0 0x35 imm32 

xor rm ubyte imm8 rm8 6 0x80 $0 imm8 
xor rm ushort imm16 rm16 6 0x81 $0 imm16 
xor rm uint imm32 rm32 6 0x81 $0 imm32 
xor rm uint imm32 rm64 6 0x81 $0 imm32 
xor rm ubyte imm8 rm16 6 0x83 $0 imm8 
xor rm ubyte imm8 rm32 6 0x83 $0 imm8 
xor rm ubyte imm8 rm64 6 0x83 $0 imm8 

xor rm R8 rm8 0 0x30 $0 $1 
xor rm R16 rm16 0 0x31 $0 $1 
xor rm R32 rm32 0 0x31 $0 $1 
xor rm R64 rm64 0 0x31 $0 $1 

xor R8 m8 0 0x32 $0 $1 
xor R16 m16 0 0x33 $0 $1 
xor R32 m32 0 0x33 $0 $1 
xor R64 m64 0 0x33 $0 $1 

or ubyte imm8 0 0x0c imm8 
or ushort imm16 0 0x0d imm16 
or uint imm32 0 0x0d imm32 

or rm ubyte imm8 rm8 1 0x80 $0 imm8 
or rm ushort imm16 rm16 1 0x81 $0 imm16 
or rm uint imm32 rm32 1 0x81 $0 imm32 
or rm uint imm32 rm64 1 0x81 $0 imm32 
or rm ubyte imm8 rm16 1 0x83 $0 imm8 
or rm ubyte imm8 rm32 1 0x83 $0 imm8 
or rm ubyte imm8 rm64 1 0x83 $0 imm8 

or rm R8 rm8 0 0x8 $0 $1 
or rm R16 rm16 0 0x9 $0 $1 
or rm R32 rm32 0 0x9 $0 $1 
or rm R64 rm64 0 0x9 $0 $1 

or R8 m8 0 0xa $0 $1 
or R16 m16 0 0xb $0 $1 
or R32 m32 0 0xb $0 $1 
or R64 m64 0 0xb $0 $1 

sal rm rm8 4 0xd2 $0 cl 
sal rm ubyte imm8 rm 8 
{
if imm8 == 1 
return emit!4 0xd0 $0 
else
return emit!4 0xc0 $0 imm8 
}
sal rm rm16 4 0xd3 $0 cl 
sal rm ubyte imm8 rm 16 
{
if imm8 == 1 
return emit!4 0xd1 $0 
else
return emit!4 0xc1 $0 imm8 
}
sal rm rm32 4 0xd3 $0 cl 
sal rm ubyte imm8 rm 32 
{
if imm8 == 1 
return emit!4 0xd1 $0 
else
return emit!4 0xc1 $0 imm8 
}
sal rm rm64 4 0xd3 $0 cl 
sal rm ubyte imm8 rm 64 
{
if imm8 == 1 
return emit!4 0xd1 $0 
else
return emit!4 0xc1 $0 imm8 
}

sar rm rm8 7 0xd2 $0 cl 
sar rm ubyte imm8 rm 8 
{
if imm8 == 1 
return emit!7 0xd0 $0 
else
return emit!7 0xc0 $0 imm8 
}
sar rm rm16 7 0xd3 $0 cl 
sar rm ubyte imm8 rm 16 
{
if imm8 == 1 
return emit!7 0xd1 $0 
else
return emit!7 0xc1 $0 imm8 
}
sar rm rm32 7 0xd3 $0 cl 
sar rm ubyte imm8 rm 32 
{
if imm8 == 1 
return emit!7 0xd1 $0 
else
return emit!7 0xc1 $0 imm8 
}
sar rm rm64 7 0xd3 $0 cl 
sar rm ubyte imm8 rm 64 
{
if imm8 == 1 
return emit!7 0xd1 $0 
else
return emit!7 0xc1 $0 imm8 
}

shl rm rm 8 sal 
shl rm ubyte imm8 rm 8 sal imm8 
shl rm rm 16 sal 
shl rm ubyte imm8 rm 16 sal imm8 
shl rm rm 32 sal 
shl rm ubyte imm8 rm 32 sal imm8 
shl rm rm 64 sal 
shl rm ubyte imm8 rm 64 sal imm8 

shr rm rm8 5 0xd2 $0 cl 
shr rm ubyte imm8 rm 8 
{
if imm8 == 1 
return emit!5 0xd0 $0 
else
return emit!5 0xc0 $0 imm8 
}
shr rm rm16 5 0xd3 $0 cl 
shr rm ubyte imm8 rm 16 
{
if imm8 == 1 
return emit!5 0xd1 $0 
else
return emit!5 0xc1 $0 imm8 
}
shr rm rm32 5 0xd3 $0 cl 
shr rm ubyte imm8 rm 32 
{
if imm8 == 1 
return emit!5 0xd1 $0 
else
return emit!5 0xc1 $0 imm8 
}
shr rm rm64 5 0xd3 $0 cl 
shr rm ubyte imm8 rm 64 
{
if imm8 == 1 
return emit!5 0xd1 $0 
else
return emit!5 0xc1 $0 imm8 
}

rcl rm rm8 2 0xd2 $0 cl 
rcl rm ubyte imm8 rm 8 
{
if imm8 == 1 
return emit!2 0xd0 $0 
else
return emit!2 0xc0 $0 imm8 
}
rcl rm rm16 2 0xd3 $0 cl 
rcl rm ubyte imm8 rm 16 
{
if imm8 == 1 
return emit!2 0xd1 $0 
else
return emit!2 0xc1 $0 imm8 
}
rcl rm rm32 2 0xd3 $0 cl 
rcl rm ubyte imm8 rm 32 
{
if imm8 == 1 
return emit!2 0xd1 $0 
else
return emit!2 0xc1 $0 imm8 
}
rcl rm rm64 2 0xd3 $0 cl 
rcl rm ubyte imm8 rm 64 
{
if imm8 == 1 
return emit!2 0xd1 $0 
else
return emit!2 0xc1 $0 imm8 
}

rcr rm rm8 3 0xd2 $0 cl 
rcr rm ubyte imm8 rm 8 
{
if imm8 == 1 
return emit!3 0xd0 $0 
else
return emit!3 0xc0 $0 imm8 
}
rcr rm rm16 3 0xd3 $0 cl 
rcr rm ubyte imm8 rm 16 
{
if imm8 == 1 
return emit!3 0xd1 $0 
else
return emit!3 0xc1 $0 imm8 
}
rcr rm rm32 3 0xd3 $0 cl 
rcr rm ubyte imm8 rm 32 
{
if imm8 == 1 
return emit!3 0xd1 $0 
else
return emit!3 0xc1 $0 imm8 
}
rcr rm rm64 3 0xd3 $0 cl 
rcr rm ubyte imm8 rm 64 
{
if imm8 == 1 
return emit!3 0xd1 $0 
else
return emit!3 0xc1 $0 imm8 
}

rol rm rm8 0 0xd2 $0 cl 
rol rm ubyte imm8 rm 8 
{
if imm8 == 1 
return emit!0 0xd0 $0 
else
return emit!0 0xc0 $0 imm8 
}
rol rm rm16 0 0xd3 $0 cl 
rol rm ubyte imm8 rm 16 
{
if imm8 == 1 
return emit!0 0xd1 $0 
else
return emit!0 0xc1 $0 imm8 
}
rol rm rm32 0 0xd3 $0 cl 
rol rm ubyte imm8 rm 32 
{
if imm8 == 1 
return emit!0 0xd1 $0 
else
return emit!0 0xc1 $0 imm8 
}
rol rm rm64 0 0xd3 $0 cl 
rol rm ubyte imm8 rm 64 
{
if imm8 == 1 
return emit!0 0xd1 $0 
else
return emit!0 0xc1 $0 imm8 
}

ror rm rm8 1 0xd2 $0 cl 
ror rm ubyte imm8 rm 8 
{
if imm8 == 1 
return emit!1 0xd0 $0 
else
return emit!1 0xc0 $0 imm8 
}
ror rm rm16 1 0xd3 $0 cl 
ror rm ubyte imm8 rm 16 
{
if imm8 == 1 
return emit!1 0xd1 $0 
else
return emit!1 0xc1 $0 imm8 
}
ror rm rm32 1 0xd3 $0 cl 
ror rm ubyte imm8 rm 32 
{
if imm8 == 1 
return emit!1 0xd1 $0 
else
return emit!1 0xc1 $0 imm8 
}
ror rm rm64 1 0xd3 $0 cl 
ror rm ubyte imm8 rm 64 
{
if imm8 == 1 
return emit!1 0xd1 $0 
else
return emit!1 0xc1 $0 imm8 
}

verr rm rm16 4 0xf0 0x00 $0 
verw rm rm16 5 0xf0 0x00 $0 

test ubyte imm8 0 0xa8 imm8 
test ushort imm16 0 0xa9 imm16 
test uint imm32 0 0xa9 imm32 

test rm ubyte imm8 rm8 0 0xf6 $0 imm8 
test rm ushort imm16 rm16 0 0xf7 $0 imm16 
test rm uint imm32 rm32 0 0xf7 $0 imm32 
test rm uint imm32 rm64 0 0xf7 $0 cast long imm32 

test rm R8 rm8 0 0x84 $0 $1 
test rm R16 rm16 0 0x85 $0 $1 
test rm R32 rm32 0 0x85 $0 $1 
test rm R64 rm64 0 0x85 $0 $1 

pop m16 0 0x8f $0 
static if !X64 
pop m32 /0 /rx 0x8f $0 
static if X64 
pop m64 /0 /rx 0x8f $0 

pop R16 /0 /e /e 0x58 $0 
static if !X64 
pop R32 /0 /e /e 0x58 $0 
static if X64 
pop R64 /0 /e /e 0x58 $0 
popds 0 0x1f 
popes 0 0x07 
popss 0 0x17 
popfs 0 0x0f 0xa1 
popgs 0 0x0f 0xa9 
popa 0 0x61 
popad 0 0x61 
popf 0 0x9d 
popfd 0 0x9d 
popfq 0 0x9d 

push m16 6 0xff $0 
static if !X64 
push m32 /6 /rx 0xff $0 
static if X64 
push m64 /6 /rx 0xff $0 

push R16 /0 /e /e 0x50 $0 
static if !X64 
push R32 /0 /e /e 0x50 $0 
static if X64 
push R64 /0 /e /e 0x50 $0 

push ubyte imm8 0 0x6a imm8 
push ushort imm16 0 0x68 imm16 
push uint imm32 0 0x68 imm32 
pushcs 0 0x0e 
pushss 0 0x16 
pushds 0 0x1e 
pushes 0 0x06 
pushfs 0 0x0f 0xa0 
pushgs 0 0x0f 0xa8 
pusha 0 0x60 
pushad 0 0x60 
pushf 0 0x9c 
pushfd 0 0x9c 
pushfq 0 0x9c 

xadd rm R8 rm8 0 0x0f 0xc0 $0 $1 
xadd rm R16 rm16 0 0x0f 0xc1 $0 $1 
xadd rm R32 rm32 0 0x0f 0xc1 $0 $1 
xadd rm R64 rm64 0 0x0f 0xc1 $0 $1 

xchg R16 /0 /e 90 $0 
xchg R32 /0 /e 90 $0 
xchg R64 /0 /e 90 $0 

xchg A B A B A 8 && valid! B8 0 0x86 $0 $1 
xchg A B A B A 16 && valid! B16 0 0x87 $0 $1 
xchg A B A B A 32 && valid! B32 0 0x87 $0 $1 
xchg A B A B A 64 && valid! B64 0 0x87 $0 $1 
xlat 0 0xd7 
static if !X64 
xlatb 0 0xd7 
static if X64 
xlatb 0 0x48 0xd7 

lar R16 m16 0 0x0f 0x02 $0 $1 
lar R16 R16 0 0x0f 0x02 $0 $1 
lar R32 m16 0 0x0f 0x02 $0 $1 
lar R32 R32 0 0x0f 0x02 $0 $1 
daa 0 0x27 
das 0 0x2f 

mul rm rm8 4 0xf6 $0 
mul rm rm16 4 0xf7 $0 
mul rm rm32 4 0xf7 $0 
mul rm rm64 4 0xf7 $0 

imul rm rm8 5 0xf6 $0 
imul rm rm16 5 0xf7 $0 
imul rm rm32 5 0xf7 $0 
imul rm rm64 5 0xf7 $0 

imul R16 rm16 0 0x0f 0xaf $0 $1 
imul R32 rm32 0 0x0f 0xaf $0 $1 
imul R64 rm64 0 0x0f 0xaf $0 $1 

imul R16 rm ubyte imm8 rm16 0 0x6b $0 $1 imm8 
imul R32 rm ubyte imm8 rm32 0 0x6b $0 $1 imm8 
imul R64 rm ubyte imm8 rm64 0 0x6b $0 $1 imm8 
imul R16 rm ushort imm16 rm16 0 0x69 $0 $1 imm16 
imul R32 rm uint imm32 rm32 0 0x69 $0 $1 imm32 
imul R64 rm uint imm32 rm64 0 0x69 $0 $1 imm32 

div rm rm8 6 0xf6 $0 
div rm rm16 6 0xf7 $0 
div rm rm32 6 0xf7 $0 
div rm rm64 6 0xf7 $0 

idiv rm rm8 7 0xf6 $0 
idiv rm rm16 7 0xf7 $0 
idiv rm rm32 7 0xf7 $0 
idiv rm rm64 7 0xf7 $0 

mov rm R8 rm8 0 0x88 $0 $1 
mov rm R16 rm16 0 0x89 $0 $1 
mov rm R32 rm32 0 0x89 $0 $1 
mov rm R64 rm64 0 0x89 $0 $1 

mov R8 m8 0 0x8a $0 $1 
mov R16 m16 0 0x8b $0 $1 
mov R32 m32 0 0x8b $0 $1 
mov R64 m64 0 0x8b $0 $1 

mov R8 ubyte imm8 /0 /e 0xb0 $0 imm8 
mov R16 ushort imm16 /0 /e 0xb8 $0 imm16 
mov R32 uint imm32 /0 /e 0xb8 $0 imm32 
mov R64 ulong imm64 /0 /e 0xb8 $0 imm64 

mov m8 ubyte imm8 0 0xc6 $0 imm8 
mov m16 ushort imm16 0 0xc7 $0 imm16 
mov m32 uint imm32 0 0xc7 $0 imm32 
mov m64 uint imm32 0 0xc7 $0 imm32 

mov R32 CR 0 0x0f 0x20 $0 $1 
mov R64 CR 0 0x0f 0x20 $0 $1 
mov CR R32 0 0x0f 0x22 $0 $1 
mov CR R64 0 0x0f 0x22 $0 $1 

mov R32 DR 0 0x0f 0x21 $0 $1 
mov R64 DR 0 0x0f 0x21 $0 $1 
mov DR R32 0 0x0f 0x23 $0 $1 
mov DR R64 0 0x0f 0x23 $0 $1 

movsx R16 rm8 0 0x0f 0xbe $0 $1 
movsx R32 rm8 0 0x0f 0xbe $0 $1 
movsx R64 rm8 0 0x0f 0xbe $0 $1 

movsx R32 rm16 0 0x0f 0xbf $0 $1 
movsx R64 rm16 0 0x0f 0xbf $0 $1 

movsxd R16 rm16 0 0x63 $0 $1 
movsxd R32 rm32 0 0x63 $0 $1 
movsxd R64 rm32 0 0x63 $0 $1 

movzx R16 rm8 0 0x0f 0xb6 $0 $1 
movzx R32 rm8 0 0x0f 0xb6 $0 $1 
movzx R64 rm8 0 0x0f 0xb6 $0 $1 

movzx R32 rm16 0 0x0f 0xb7 $0 $1 
movzx R64 rm16 0 0x0f 0xb7 $0 $1 

call ushort rel16 0 0xe8 rel16 
call uint rel32 0 0xe8 rel32 

call R16 2 0xff $0 
call R32 2 0xff $0 
call R64 2 0xff $0 

call m16 3 0xff $0 
call m32 3 0xff $0 
call m64 3 0xff $0 

loop string name branches ~= tuple cast ptrdiff_t buffer.length name "loop" name !in labels 
loope string name branches ~= tuple cast ptrdiff_t buffer.length name "loope" name !in labels 
loopne string name branches ~= tuple cast ptrdiff_t buffer.length name "loopne" name !in labels 

jmp string name branches ~= tuple cast ptrdiff_t buffer.length name "jmp" name !in labels 
jmp rm rm16 4 0xff $0 
jmp rm rm32 4 0xff $0 
jmp rm rm64 4 0xff $0 
/* jmp m16 5 0xff $0 
jmp m32 5 0xff $0 
jmp m64 5 0xff $0 */

jmp ushort imm16 0 0xea imm16 
jmp uint imm32 0 0xea imm32 

ja string name branches ~= tuple cast ptrdiff_t buffer.length name "ja" name !in labels 
jae string name branches ~= tuple cast ptrdiff_t buffer.length name "jae" name !in labels 
jb string name branches ~= tuple cast ptrdiff_t buffer.length name "jb" name !in labels 
jbe string name branches ~= tuple cast ptrdiff_t buffer.length name "jbe" name !in labels 
jc string name branches ~= tuple cast ptrdiff_t buffer.length name "jc" name !in labels 
jcxz string name branches ~= tuple cast ptrdiff_t buffer.length name "jcxz" name !in labels 
jecxz string name branches ~= tuple cast ptrdiff_t buffer.length name "jecxz" name !in labels 
jrcxz string name branches ~= tuple cast ptrdiff_t buffer.length name "jrcxz" name !in labels 
je string name branches ~= tuple cast ptrdiff_t buffer.length name "je" name !in labels 
jg string name branches ~= tuple cast ptrdiff_t buffer.length name "jg" name !in labels 
jge string name branches ~= tuple cast ptrdiff_t buffer.length name "jge" name !in labels 
jl string name branches ~= tuple cast ptrdiff_t buffer.length name "jl" name !in labels 
jle string name branches ~= tuple cast ptrdiff_t buffer.length name "jle" name !in labels 
jna string name branches ~= tuple cast ptrdiff_t buffer.length name "jna" name !in labels 
jnae string name branches ~= tuple cast ptrdiff_t buffer.length name "jnae" name !in labels 
jnb string name branches ~= tuple cast ptrdiff_t buffer.length name "jnb" name !in labels 
jnbe string name branches ~= tuple cast ptrdiff_t buffer.length name "jnbe" name !in labels 
jnc string name branches ~= tuple cast ptrdiff_t buffer.length name "jnc" name !in labels 
jne string name branches ~= tuple cast ptrdiff_t buffer.length name "jne" name !in labels 
jng string name branches ~= tuple cast ptrdiff_t buffer.length name "jng" name !in labels 
jnge string name branches ~= tuple cast ptrdiff_t buffer.length name "jnge" name !in labels 
jnl string name branches ~= tuple cast ptrdiff_t buffer.length name "jnl" name !in labels 
jnle string name branches ~= tuple cast ptrdiff_t buffer.length name "jnle" name !in labels 
jno string name branches ~= tuple cast ptrdiff_t buffer.length name "jno" name !in labels 
jnp string name branches ~= tuple cast ptrdiff_t buffer.length name "jnp" name !in labels 
jns string name branches ~= tuple cast ptrdiff_t buffer.length name "jns" name !in labels 
jnz string name branches ~= tuple cast ptrdiff_t buffer.length name "jnz" name !in labels 
jo string name branches ~= tuple cast ptrdiff_t buffer.length name "jo" name !in labels 
jp string name branches ~= tuple cast ptrdiff_t buffer.length name "jp" name !in labels 
jpe string name branches ~= tuple cast ptrdiff_t buffer.length name "jpe" name !in labels 
jpo string name branches ~= tuple cast ptrdiff_t buffer.length name "jpo" name !in labels 
js string name branches ~= tuple cast ptrdiff_t buffer.length name "js" name !in labels 
jz string name branches ~= tuple cast ptrdiff_t buffer.length name "jz" name !in labels 

rep size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0xf3~buffer[ buffer.length - size ..$];
return size 1;
}

repe size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0xf3~buffer[ buffer.length - size ..$];
return size 1;
}

repz size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0xf3~buffer[ buffer.length - size ..$];
return size 1;
}

repne size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0xf2~buffer[ buffer.length - size ..$];
return size 1;
}

repnz size_t size 
{
buffer = buffer[0.. buffer.length - size ]~0xf2~buffer[ buffer.length - size ..$];
return size 1;
}

movs m8 m8 0 0xa4 $0 $1 
movs m16 m16 0 0xa5 $0 $1 
movs m32 m32 0 0xa5 $0 $1 
movs m64 m64 0 0xa5 $0 $1 
movsb 0 0xa4 
movsw 0 0x66 0xa5 
movsd 0 0xa5 
movsq 0 0x48 0xa5 

cmps m8 m8 0 0xa6 $0 $1 
cmps m16 m16 0 0xa7 $0 $1 
cmps m32 m32 0 0xa7 $0 $1 
cmps m64 m64 0 0xa7 $0 $1 
cmpsb 0 0xa6 
cmpsw 0 0x66 0xa7 
cmpsd 0 0xa7 
cmpsq 0 0x48 0xa7 

scas m8 0 0xae $0 
scas m16 0 0xaf $0 
scas m32 0 0xaf $0 
scas m64 0 0xaf $0 
scasb 0 0xae 
scasw 0 0x66 0xaf 
scasd 0 0xaf 
scasq 0 0x48 0xaf 

lods m8 0 0xac $0 
lods m16 0 0xad $0 
lods m32 0 0xad $0 
lods m64 0 0xad $0 
lodsb 0 0xac 
lodsw 0 0x66 0xad 
lodsd 0 0xad 
lodsq 0 0x48 0xad 

stos m8 0 0xaa $0 
stos m16 0 0xab $0 
stos m32 0 0xab $0 
stos m64 0 0xab $0 
stosb 0 0xaa 
stosw 0 0x66 0xab 
stosd 0 0xab 
stosq 0 0x48 0xab 

inal ubyte imm8 0 0xe4 imm8 
inal 0 0xec 

_in ubyte imm8 0 0xe5 imm8 
_in 0 0xed 

ins m8 0 0x6c $0 
ins m16 0 0x6d $0 
ins m32 0 0x6d $0 
insb 0 0x6c 
insw 0 0x66 0x6d 
insd 0 0x6d 

outal ubyte imm8 0 0xe6 imm8 
outal 0 0xee 

_out ubyte imm8 0 0xe7 imm8 
_out 0 0xef 

outs m8 0 0x6e $0 
outs m16 0 0x6f $0 
outs m32 0 0x6f $0 
outsb 0 0x6e 
outsw 0 0x66 0x6f 
outsd 0 0x6f 

seta rm rm8 0 0x0f 0x97 $0 
setae rm rm8 0 0x0f 0x93 $0 
setb rm rm8 0 0x0f 0x92 $0 
setbe rm rm8 0 0x0f 0x96 $0 
setc rm rm8 0 0x0f 0x92 $0 
sete rm rm8 0 0x0f 0x94 $0 
setg rm rm8 0 0x0f 0x9f $0 
setge rm rm8 0 0x0f 0x9d $0 
setl rm rm8 0 0x0f 0x9c $0 
setle rm rm8 0 0x0f 0x9e $0 
setna rm rm8 0 0x0f 0x96 $0 
setnae rm rm8 0 0x0f 0x92 $0 
setnb rm rm8 0 0x0f 0x93 $0 
setnbe rm rm8 0 0x0f 0x97 $0 
setnc rm rm8 0 0x0f 0x93 $0 
setne rm rm8 0 0x0f 0x95 $0 
setng rm rm8 0 0x0f 0x9e $0 
setnge rm rm8 0 0x0f 0x9c $0 
setnl rm rm8 0 0x0f 0x9d $0 
setnle rm rm8 0 0x0f 0x9f $0 
setno rm rm8 0 0x0f 0x91 $0 
setnp rm rm8 0 0x0f 0x9b $0 
setns rm rm8 0 0x0f 0x99 $0 
setnz rm rm8 0 0x0f 0x95 $0 
seto rm rm8 0 0x0f 0x90 $0 
setp rm rm8 0 0x0f 0x9a $0 
setpe rm rm8 0 0x0f 0x9a $0 
setpo rm rm8 0 0x0f 0x9b $0 
sets rm rm8 0 0x0f 0x98 $0 
setz rm rm8 0 0x0f 0x94 $0 
m8 bytePtr ARGS... ARGS args m8 args 
m16 wordPtr ARGS... ARGS args m16 args 
m32 dwordPtr ARGS... ARGS args m32 args 
m64 qwordPtr ARGS... ARGS args m64 args 
m128 r128wordPtr ARGS... ARGS args m128 args 
m256 r256wordPtr ARGS... ARGS args m256 args 
m512 zmmwordPtr ARGS... ARGS args m512 args 
}
unittest
{
Block!true block;
with block 
{
mov eax ecx 
movsxd rcx eax 
mov ebx 1 
// TODO: pop and push are emitting REX but shouldn't
pop rbx 
push rcx 
jl "a" 
label "a" 
popf 
// Not supported in 64-bit
//pusha 
ret 
retf 3 
jmp "a" 
jb "a" 
setz al 
//aad 17 
insb 
outal 
call 2 
lock add eax ebx 
xacquire_lock sub si di 
movsb 
// TODO: Make emittable instructions condiitonal?
//daa 
//das 
//aaa 
//pushcs 
mov eax dwordPtr ebx 
// TODO: This is outputting 0x67 when it should output REX
mov eax dwordPtr rbx 
//verr si 
stc 
std 
clc 
wait 
fwait 
monitor 
lfence 
sfence 
retf 
test al bl 
hlt 
swapgs 
inc eax 
dec rax 
dec rdi 
sub rdi 10 
mul esi 
scasb 
cmpsb 
pause 
iret 
mov esp dwordPtr rdx 
pop rsp 
mov rbp rsp 
}
import tern.digest;
import std.stdio;
debug writeln block.finalize .toHexString 
}
unittest
{
import gallinule.asmi;
/*
//0fh 0fh $0 $1 9eh pfadd r64 rm64
pfadd rm641 R64 o/0 rm641 o1 rm64164 /0 /0 128 0x0f 0x0f o0 o1 0x9e 

//0fh 0fh $0 $1 9ah pfsub r64 rm64
pfsub rm641 R64 o/0 rm641 o1 rm64164 /0 /0 128 0x0f 0x0f o0 o1 0x9a 
*/
pragma msg parse! "3dnow.asmi" 
}